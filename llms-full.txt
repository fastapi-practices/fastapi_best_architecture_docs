---
url: /fastapi_best_architecture_docs/index.md
---
# fba | FastAPI Best Architecture

---

---
url: /fastapi_best_architecture_docs/article/85vk4vsd/index.md
description: >-
  FastAPI Practices 及其生态系统发展的背后是一个由开源社区人员组成的团队，我们对团队中的任何成员以及所有的关注者都致以崇高的敬意；
  我们欢迎每一位开源伙伴的加入。
---
# FastAPI Practices
[申请 **加入团队**](./join.md){.read-more}

---

---
url: /fastapi_best_architecture_docs/backend/deploy/Docker.md
---
# Docker 部署
::: info
一个还不错的教程网站：[Docker - 从入门到实践](https://yeasy.gitbook.io/docker_practice)
:::

## 本地部署

本地部署是为了能够快捷的提供本地 API 服务

### 后端

:::: steps

1. env

   在 `backend` 目录打开终端，创建环境变量文件

   ```shell:no-line-numbers
   touch .env
   ```

   将初始化环境变量配置拷贝到环境变量文件中

   ```shell:no-line-numbers
   cp .env.example .env
   ```

2. 按需修改配置文件 `backend/core/conf.py` 和 `.env`

3. 构建容器

   在项目根目录中打开终端，执行以下命令

   ::: warning
   如果容器要在本地启动，需要将 `.env` 中的 `127.0.0.1` 更改为 `host.docker.internal`
   :::

   ::: tabs#dockerfile
   @tab fba

   ```shell:no-line-numbers
   docker build -f Dockerfile -t fba_backend_independent .
   ```

   @tab celery

   ```shell:no-line-numbers
   docker build --build-arg SERVER_TYPE=celery -t fba_celery_independent .
   ```

   :::

4. 启动容器

   由于构建不包含数据库，请确保本地已安装并启动相关数据库（postgresql / mysql、redis）

   ::: tabs#dockerfile
   @tab fba

   ```shell:no-line-numbers
   docker run -d -p 8000:8000 --name fba_server fba_backend_independent
   ```

   @tab celery

   ```shell:no-line-numbers
   docker run -d -p 8555:8555 --name fba_celery fba_celery_independent
   ```

   :::

::::

### 前端

[请移步至 **前端快速开始**](../../frontend/summary/quick-start.md){.read-more}

## 服务器部署

::: warning
此教程以 https 为例
:::

::: info
免费 SSL 证书推荐使用 [httpsok-SSL 证书自动续期](https://httpsok.com/p/4Qjd)，一行命令，轻松搞定 SSL
证书自动续签，支持：nginx、通配符证书、七牛云、腾讯云、阿里云、CDN、OSS、LB（负载均衡）
:::

### 后端

:::: steps

1. 拉取代码到服务器

   将代码拉取到服务器通常采用 ssh 方式（更安全），当然你也可以选择使用 https 方式，具体方式请根据个人自行决定

2. env

   在 `backend` 目录打开终端，创建环境变量文件

   ```shell:no-line-numbers
   touch .env
   ```

   进入 `deploy/backend/docker-compose` 目录，按需修改 `.env.server` 文件

   ::: info
   我们在 docker-compose 脚本内通过挂载的方式使用 `.env.server` 文件作为 fba 环境变量文件，因此，本地修改此文件，将同步更新至
   docker 容器，这意味着，修改环境变量将无需重新 build
   :::

   ::: warning
   如果您正在使用 MySQL 数据库，需修改 `.env.server` 部分配置如下：

   ```dotenv:no-line-numbers
   # Database
   DATABASE_TYPE='mysql'
   DATABASE_HOST='fba_mysql'
   DATABASE_PORT=3306
   DATABASE_USER='root'
   DATABASE_PASSWORD='123456'
   ```

   :::

3. 按需修改配置文件 `backend/core/conf.py`

4. 更新 docker-compose 脚本

   脚本 `docker-compose.yml` 中有相关注释说明，根据需要进行修改即可

5. 执行一键启动命令

   在项目根目录中打开终端，执行以下命令

   ::: warning
   命令执行期间遇到镜像拉取问题请自行 Google
   :::

   ```shell:no-line-numbers
   docker-compose up -d --build
   ```

6. 等待命令执行完成
   ::::

### 前端

[请移步至 **前端快速开始**](../../frontend/deploy/docker.md){.read-more}

## 注意事项

::: warning
不建议频繁使用 `docker-compose up -d --build` 命令，此命令每次执行都会重新构建容器，并将原容器自动本地备份保留，这会导致硬盘空间迅速锐减
:::

[15 个 Docker 容器自动化管理的脚本](https://www.yuque.com/fcant/devops/itkfyytisf9z84y6){.read-more}

清理未使用的镜像

```shell:no-line-numbers
docker image prune
```

清理未使用的容器

```shell:no-line-numbers
docker container prune
```

清理所有未使用的镜像、容器、网络和构建缓存

```shell:no-line-numbers
docker system prune
```

---

---
url: /fastapi_best_architecture_docs/backend/deploy/legacy.md
---
# 传统部署
::: info
由于传统部署涉及修改的地方较多且较为复杂，因此无法提供此部署教程
:::

::: tip
免费 SSL 证书推荐使用 [httpsok-SSL证书自动续期](https://httpsok.com/p/4Qjd)，一行命令，轻松搞定 SSL
证书自动续签，支持：nginx、通配符证书、七牛云、腾讯云、阿里云、CDN、OSS、LB（负载均衡）
:::

---

---
url: /fastapi_best_architecture_docs/backend/ide/cursor.md
---
# cursor
我们在 cursor 中定做了一些规则，或许可以帮助您更好的使用 AI 生成代码

查看 cursor 官方文档：[rules-for-ai](https://docs.cursor.com/context/rules-for-ai)，然后添加以下规则

::: warning
我们未对规则进行 token 消耗量测试，请根据实际情况自行抉择
:::

[**Cursor** 官网地址](https://www.cursor.com/){.read-more}

### fba

::: note
此规则仅限用于 fba 项目
:::

@[code mdc](../../code/fastapi.mdc)

### Python

::: note
此规则可用于任何 Python 3.10+ 项目
:::

@[code mdc](../../code/python.mdc)

---

---
url: /fastapi_best_architecture_docs/backend/ide/vscode.md
---
# vscode
[**Visual Studio Code** 官网地址](https://code.visualstudio.com/){.read-more}

## DEBUG

如果你想在 vscode 中对 fba 进行调试，请创建 `.vscode/launch.json` 文件并添加以下配置

@[code json](../../code/launch.json5)

### 效果图

![vscode 调试](/images/vscode_debug.png)

---

---
url: /fastapi_best_architecture_docs/backend/reference/apscheduler.md
---
# APScheduler
我们在最初的框架实现中，使用的是 APScheduler，但后来我们迁移到了
Celery，详情请查看：[#225](https://github.com/fastapi-practices/fastapi_best_architecture/discussions/225)

FastAPI + APScheduler 现已作为独立仓库发行，它的优势在于其灵活性与实时动态任务，如果你没有繁重的任务需求，它将是一个不错的选择

::: warning
我们计划将 APScheduler 制作为 fba
插件，但需要等待 [4.0](https://github.com/agronholm/apscheduler/issues/465#issuecomment-2818889743)
版本发布
:::

---

---
url: /fastapi_best_architecture_docs/backend/reference/celery.md
---
# celery
Celery 对于绝大数人来讲，学习路线非常曲折，很难以理解其设计的复杂性，加上它不是很优雅的文档（当然，它很全面），让大多数人将其抛之脑后，今天，我们一起来打破障碍，拥抱
celery

## 为什么选择 Celery?

Celery 是一个基于 Python
开发的分布式任务队列系统，它在处理繁重计算或复杂任务具备极好的优势，因为它不会和主线程应用共享进程，而是在一个独立的进程中运行，这意味着，这些任务将被异步处理，而不会占用主线程应用的资源，这可以大大提高主应用程序的响应速度和吞吐量；你可以在我们的项目中找到迁移到
Celery 的相关讨论，请查看：[#225](https://github.com/fastapi-practices/fastapi_best_architecture/discussions/225)

## Broker（消息代理/中间件）

在 [Celery 词汇表](https://docs.celeryq.dev/projects/celery-enhancement-proposals/en/latest/glossary.html?highlight=broker)
中对 Broker 有以下描述：

> [企业集成模式 ](https://www.enterpriseintegrationpatterns.com/)
> 将 [消息代理 ](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageBroker.html)
> 定义为一种架构构件，它可以接收来自多个目的地的
> [消息](https://docs.celeryq.dev/projects/celery-enhancement-proposals/en/latest/glossary.html?highlight=broker#term-Message)
> ，确定正确的目的地并将消息路由到正确的通道

在 Celery 中，我们可以将它视为存储已创建的调度任务并进行消息传递的桥梁，而它本身并不会执行任务；当任务被调度时，Broker
会存储调度任务消息，当 Worker 执行任务时，会从 Broker 调度任务消息中提取任务，因此，Broker 是 Celery 工作的重要组件

Celery 在文档 [后端和代码](https://docs.celeryq.dev/en/v5.4.0/getting-started/backends-and-brokers/index.html)
中列出了所支持的消息代理，fba 将通过 `ENVIRONMENT` 环境变量来自动选择使用 Redis 还是 *RabbitMQ*

```python
@model_validator(mode='before')
@classmethod
def validate_celery_broker(cls, values):
    if values['ENVIRONMENT'] == 'prod':
        # dev 环境默认使用 redis，如果是 prod 环境，则使用 rabbitmq
        values['CELERY_BROKER'] = 'rabbitmq'
    return values
```

## Worker

Worker 是调度任务的实际执行者，它从 Broker 中提取任务并执行，并且这是一种监听行为，当 Broker 接收调度信息后，Worker
就会提取任务并执行

Worker 可以同时运行多个以进行分布式处理，默认情况下，Celery 会为计算机的启动对应内核数量的 Worker，假如计算机有 16
个内核，那么，将默认启动 16 个 Worker

如果没有 Worker 运行，调度任务消息会在 Broker 中累积，直到有 Worker 接收并执行

## Backend

Celery 用户指南中的 [任务页面](https://docs.celeryq.dev/en/v5.4.0/userguide/tasks.html#result-backends) 对 Backend
有如下介绍：

> 如果你想跟踪任务或需要返回值，那么 Celery 必须将状态存储或发送到某个地方，以便日后检索。有几种内置的结果后端可供您选择：SQLAlchemy/Django
> ORM、Memcached、RabbitMQ/QPid (rpc) 和 Redis，您也可以定义自己的后端；没有哪种后端能很好地适用于每种使用情况。
> 您应该了解每个后端的优缺点，然后选择最适合您需求的后端

我们在 fba 中使用数据库作为默认存储后端

场景假设：跟踪异步任务的结果并返回结果

你正在构建一个耗时的生成测试报告的任务程序，为了在页面中直观的看到效果，你可以在前端项目中触发启动任务接口，FastAPI
收到请求后，触发 Celery 执行任务，此时，任务已经在 Celery 中执行，而不会阻塞 FastAPI 主应用，也不会占用 FastAPI
主应用资源，等待任务执行完成后，FastAPI 将返回任务结果，然后前端再对返回结果进行处理

在上述场景中，任务会将结果存储到 Backend，它不会存储未处理任务的状态，只有任务有结果后，才会进行存储；你可以在 Celery 状态文档
中查看所有状态信息；Celery 执行任务并不强制要求使用 Backend，但是，如果你需要查看任务的结果，则必须使用 Backend

## 优雅的集成

我们在 fba 中以非常优雅的方式集成了 Celery，你无需担心 Celery 苛刻的文件结构成本，只需通过简单的配置就可以轻松使用它，并且，我们支持直接创建异步函数的任务，
\==在 Celery6.0 版本之前，官网不提供异步函数支持==

进入源码 `backend/app` 目录，其中，task 目录就是我们的 Celery 应用程序，如果你不想使用它，而是使用其他任务应用，可以直接删除此文件夹

进入 task 目录后，其中 `celery.py` 是 Celery 的初始化文件，包含了启动 Celery
启动的参数配置，此文件无需进行任何修改，下面，我们将通过视频进行详细介绍：[Celery 集成](https://www.bilibili.com/video/BV1KjkmYdE7q/?share_source=copy_web\&vd_source=ccb2aae47e179a51460c20d165021cb7)

## 高级用法

### 执行池

我们要根据实际情况为 worker 选择不同的执行池，目前推荐以下几种类型：

::: tabs

@tab prefork

任务涉及大量计算（如图像处理、数据计算等）

```bash
celery -A app.task.celery worker -l info -P prefork
```

@tab threads

不需要异步

```bash
celery -A app.task.celery worker -l info -P threads
```

@tab gevent

任务主要是 I/O 密集型且需要异步操作

```bash
celery -A app.task.celery worker -l info -P gevent
```

:::

### 并发数

celery 提供了 worker 并发数 `-c` 设置，参考如下：

```bash
celery -A app.task.celery worker -l info -P gevent -c 1000
```

::: tabs

@tab prefork

并发数建议设置为 CPU 核心数的 1 到 2 倍

@tab threads

并发数建议设置为 CPU 核心数的 2 到 10 倍

@tab gevent

并发数建议设置为 100 ～ 1000

:::

### 队列

celery 提供了 `queue`（队列），我们可以在 celery 配置中添加如下代码：

```python
app.conf.task_queues = (
    Queue('cpu_bind', routing_key='cpu'),  # cpu 密集型绑定队列
    Queue('io_bind', routing_key='io'),    # io 密集型绑定队列
    Queue('all_in'),                   # 无路由键的简单队列
)
```

启动 worker 时，需要添加 `-Q` 参数指定队列进行启动，例如：

```bash
celery -A app.task.celery worker -l info -P gevent -c 1000 -Q cpu_bind  # 启动 cpu worker
celery -A app.task.celery worker -l info -P gevent -c 1000 -Q io_bind  # 启动 io worker
```

接下来，我们就可以像下面这样在任务定义的时候指定队列运行任务了

```python
@celery_app(queue='io_bind')
async def io_bind_task():
    ...
```

---

---
url: /fastapi_best_architecture_docs/backend/reference/cli.md
---
# CLI
fba 内置了便利的 CLI 支持，安装依赖后，尝试在终端输入 `fba -h` 或 `fba --help` 以查看更多信息

::: demo-wrapper img
![cli](/images/cli.png)
:::

---

---
url: /fastapi_best_architecture_docs/backend/reference/code-generation.md
---
# 代码生成
> \[!WARNING]
> API 调用无法直观的预览代码生成结果，它必须配合前端项目使用，请查看查看 [效果预览](#效果预览)

## 概念

代码生成包含【业务】和【模型】两个模块

### 业务

包含代码生成的相关配置，详情请查看：`backend/app/generator/model/gen_business.py`

### 模型

包含代码生成所需要的模型列信息，就像正常定义模型列一样，目前支持的功能有限

## 工作模式

目前包含两种工作模式，分别为手动和自动

### 手动

::: tip
此方法适用于直接通过前端定义数据库表和列
:::

1. 通过创建业务接口手动添加一项业务数据
2. 通过模型创建接口手动添加模型列
3. 访问 `preview`（预览）、`generate`（磁盘写入）、`download`（下载）接口

### 自动

::: tip
此方法适用于已在数据库中定义好数据库表和列
:::

1. 访问 `tables` 接口，自动获取数据库表名列表
2. 访问 `import` 接口，导入数据库已有的数据库表，自动创建业务数据和模型列数据
3. 访问 `preview`（预览）、`generate`（磁盘写入）、`download`（下载）接口

## 效果预览

![cg1](/images/code-generator1.png)

![cg2](/images/code-generator2.png)

---

---
url: /fastapi_best_architecture_docs/backend/reference/config.md
---
# 配置
配置文件位于 `backend/core/conf.py`，fba 内的所有应用和插件配置都应统一放置在此文件内

## 环境配置

### `ENVIRONMENT` &#x20;

指定环境模式，当设置为 `prod` 时，openapi 相关在线文档将被禁止访问

## FastAPI 配置

### `FASTAPI_API_V1_PATH`&#x20;

API 版本号配置

### `FASTAPI_TITLE`&#x20;

openapi 相关在线文档标头配置

### `FASTAPI_DESCRIPTION`&#x20;

openapi 相关在线文档描述信息

### `FASTAPI_DOCS_URL`&#x20;

docs 在线文档地址

### `FASTAPI_REDOC_URL`&#x20;

redoc 在线文档地址

### `FASTAPI_OPENAPI_URL`&#x20;

openapi JSON 数据在线地址

### `FASTAPI_STATIC_FILES`&#x20;

是否开启 FastAPI 静态文件服务

## 数据库配置

### `DATABASE_TYPE` &#x20;

指定数据库类型，仅支持 `postgresql` 和 `mysql`，需注意第三方插件兼容性

### `DATABASE_HOST` &#x20;

提供数据库的主机地址

### `DATABASE_PORT` &#x20;

提供数据库的主机端口号

### `DATABASE_USER` &#x20;

连接数据库所使用的用户名

### `DATABASE_PASSWORD` &#x20;

连接数据库所使用的密码

### `DATABASE_ECHO`&#x20;

是否输出 sqlalchemy 操作日志

### `DATABASE_POOL_ECHO`&#x20;

是否输出 sqlalchemy 线程池操作日志

### `DATABASE_SCHEMA`&#x20;

需要连接的数据库

### `DATABASE_CHARSET`&#x20;

数据库字符集，仅用于 mysql

## Redis 配置

### `REDIS_TIMEOUT` &#x20;

连接 Redis 数据库超时时长

### `REDIS_HOST`&#x20;

连接 Redis 数据库的主机地址

### `REDIS_PORT`&#x20;

连接 Redis 数据库的主机端口号

### `REDIS_PASSWORD`&#x20;

连接 Redis 数据库的密码

### `REDIS_DATABASE`&#x20;

全局默认使用的 Redis 逻辑数据库（0 - 15）

## Token 配置

### `TOKEN_SECRET_KEY` &#x20;

token 生成和解析密钥，用于防止 token 被恶意篡改，密钥生成：`secrets.token_urlsafe(32)`

::: danger
请妥善保管此值，以免遭受恶意攻击
:::

### `TOKEN_ALGORITHM`&#x20;

token 加密算法

### `TOKEN_EXPIRE_SECONDS`&#x20;

token 过期时长

### `TOKEN_REFRESH_EXPIRE_SECONDS`&#x20;

刷新 token 过期时长

### `TOKEN_REDIS_PREFIX`&#x20;

token 存储到 Redis 时的前缀

### `TOKEN_EXTRA_INFO_REDIS_PREFIX`&#x20;

token 扩展信息存储到 Redis 时的前缀

### `TOKEN_ONLINE_REDIS_PREFIX`&#x20;

token 在线状态存储到 Redis 时的前缀

### `TOKEN_REFRESH_REDIS_PREFIX`&#x20;

刷新 token 存储到 Redis 时的前缀

### `TOKEN_REQUEST_PATH_EXCLUDE`&#x20;

JWT / RBAC 路由白名单，在此配置内的请求地址将不会校验 token 的真伪性

::: warning
fba 内通过 JWT 中间件解析 token 获取用户信息，并将用户信息赋值给 FastAPI request 对象，如果路由包含在此配置中，
`request.user` 将不可用
:::

### `TOKEN_REQUEST_PATH_EXCLUDE_PATTERN`&#x20;

JWT / RBAC 路由白名单正则模式，从路由头部开始匹配，与之匹配的请求地址将不会校验 token 真伪性，注意项同上

## JWT 配置

### `JWT_USER_REDIS_PREFIX`&#x20;

JWT 中间件存储用户信息到 Redis 时的前缀

## RBAC 配置

[更多详情](./RBAC.md){.read-more}

### `RBAC_ROLE_MENU_MODE`&#x20;

是否开启 RBAC 角色菜单模式

### `RBAC_ROLE_MENU_EXCLUDE`&#x20;

开启 RBAC 角色菜单模式时，跳过 RBAC 鉴权的标识（当接口权限标识和用户菜单权限标识相同时）

## Cookie 配置

### `COOKIE_REFRESH_TOKEN_KEY`&#x20;

将刷新 token 存储到 cookie 时的键名

### `COOKIE_REFRESH_TOKEN_EXPIRE_SECONDS`&#x20;

将刷新 token 存储到 cookie 时的过期时长

## 验证码配置

### `CAPTCHA_LOGIN_REDIS_PREFIX`&#x20;

验证码登录时，验证码存储到 Redis 时的前缀

### `CAPTCHA_LOGIN_EXPIRE_SECONDS`&#x20;

验证码登录时，验证码过期时长

## 数据权限配置

### `DATA_PERMISSION_MODELS`&#x20;

允许进行数据过滤的 SQLA 模型，模型值必须以模块字符串的方式定义

### `DATA_PERMISSION_COLUMN_EXCLUDE`&#x20;

排除允许进行数据过滤的 SQLA 模型列，例如 id, password 等

## Socket.IO 配置

### `WS_NO_AUTH_MARKER`&#x20;

连接 socket.io 服务时跳过用户验证的标记，应将其直接定义为 token 值进行传输

::: danger
请妥善保管此值，以免遭受恶意攻击
:::

## CORS 配置

### `CORS_ALLOWED_ORIGINS`&#x20;

跨域请求时允许的来源，末尾不带 `/`，例如：`http//127.0.0.1:8000`

### `CORS_EXPOSE_HEADERS`&#x20;

跨域公开标头，允许将此标头添加到请求标头中

## 中间件配置

### `MIDDLEWARE_CORS`&#x20;

是否启用跨域中间件

## 请求限制配置

### `REQUEST_LIMITER_REDIS_PREFIX`&#x20;

记录请求频率信息到 Redis 时的前缀

## 时间配置

### `DATETIME_TIMEZONE`&#x20;

全局时区

### `DATETIME_FORMAT`&#x20;

将时间转为时间字符串的格式

## 文件上传配置

::: warning
部分配置可能被 nginx 覆盖
:::

### `UPLOAD_READ_SIZE`&#x20;

上传文件时，每次读取文件内容的缓冲大小

### `UPLOAD_IMAGE_EXT_INCLUDE`&#x20;

允许上传的图片文件类型

### `UPLOAD_IMAGE_SIZE_MAX`&#x20;

允许上传的图片文件最大尺寸

### `UPLOAD_VIDEO_EXT_INCLUDE`&#x20;

允许上传的视频文件类型

### `UPLOAD_VIDEO_SIZE_MAX`&#x20;

允许上传的视频文件最大尺寸

## 演示模式配置

### `DEMO_MODE`&#x20;

是否开启演示模式，开启时，仅允许访问 `GET` 和 `OPTIONS` 请求

### `DEMO_MODE_EXCLUDE`&#x20;

开启演示模式时，不进行请求限制的接口

## IP 定位配置

### `IP_LOCATION_PARSE`&#x20;

请求发起者的定位信息获取模式

### `IP_LOCATION_REDIS_PREFIX`&#x20;

定位信息存储到 Redis 时的前缀

### `IP_LOCATION_EXPIRE_SECONDS`&#x20;

定位信息缓存时长

## Trace ID

### `TRACE_ID_REQUEST_HEADER_KEY`&#x20;

跟踪 ID 请求头键名

### `TRACE_ID_LOG_LENGTH`&#x20;

跟踪 ID 日志长度，必须小于等于 32

### `TRACE_ID_LOG_DEFAULT_VALUE`&#x20;

跟踪 ID 日志默认值

## 日志

### `LOG_FORMAT`&#x20;

日志内容格式（控制台和文件同享）

## 日志（控制台）

### `LOG_STD_LEVEL`&#x20;

日志记录级别

## 日志（文件）

### `LOG_FILE_ACCESS_LEVEL`&#x20;

访问日志记录级别

### `LOG_FILE_ERROR_LEVEL`&#x20;

错误日志记录级别

### `LOG_ACCESS_FILENAME`&#x20;

访问日志文件名

### `LOG_ERROR_FILENAME`&#x20;

错误日志文件名

## 操作日志

### `OPERA_LOG_ENCRYPT_SECRET_KEY` &#x20;

操作日志加密密钥，当使用对称加密算法加密操作日志时，将十分重要，密钥生成：
`os.urandom(32).hex()`

::: danger
请妥善保管此值，以免遭受恶意攻击
:::

### `OPERA_LOG_PATH_EXCLUDE`&#x20;

操作日志路径排除，在此配置内的请求地址不会记录操作日志

### `OPERA_LOG_ENCRYPT_TYPE`&#x20;

操作日志中的接口请求参数加密类型

* 0：AES (性能损耗)
* 1：md5
* 2：ItsDangerous
* 3：不加密
* others：直接将内容替换为 \*\*\*\*\*\*

### `OPERA_LOG_ENCRYPT_KEY_INCLUDE`&#x20;

加密操作日志中的接口请求参数

### `OPERA_LOG_QUEUE_BATCH_CONSUME_SIZE`&#x20;

操作日志队列批量消费大小，达到上限后，操作日志将批量写入数据库

### `OPERA_LOG_QUEUE_TIMEOUT`&#x20;

操作日志队列超时时长，达到上限后，操作日志将批量写入数据库

## 插件配置

### `PLUGIN_PIP_CHINA`&#x20;

通过 pip 下载插件依赖时，是否使用国内源

### `PLUGIN_PIP_INDEX_URL`&#x20;

通过 pip 下载插件依赖时的索引地址

### `PLUGIN_REDIS_PREFIX`&#x20;

插件信息存储到 Redis 时的前缀

## 应用：Task

### `CELERY_BROKER_REDIS_DATABASE` &#x20;

Celery 代理使用的 Redis 逻辑数据库

### `CELERY_RABBITMQ_HOST` &#x20;

Celery 连接 RabbitMQ 服务的主机地址

### `CELERY_RABBITMQ_PORT` &#x20;

Celery 连接 RabbitMQ 服务的主机端口号

### `CELERY_RABBITMQ_USERNAME` &#x20;

Celery 连接 RabbitMQ 服务的用户名

### `CELERY_RABBITMQ_PASSWORD` &#x20;

Celery 连接 RabbitMQ 服务的密码

### `CELERY_BROKER`&#x20;

Celery 代理模式（开发模式默认使用 Redis，线上模式强制切换为 Rabbitmq）

### `CELERY_REDIS_PREFIX`&#x20;

Celery 数据存储到 Redis 时的前缀

### `CELERY_TASK_MAX_RETRIES`&#x20;

Celery 任务执行失败时的最大重试次数

## 插件：Code Generator

#### `CODE_GENERATOR_DOWNLOAD_ZIP_FILENAME`&#x20;

下载代码时的 ZIP 压缩包文件名

## 插件：OAuth2

### `OAUTH2_GITHUB_CLIENT_ID` &#x20;

GitHub 客户端 ID

### `OAUTH2_GITHUB_CLIENT_SECRET` &#x20;

GitHub 客户端密钥

### `OAUTH2_LINUX_DO_CLIENT_ID` &#x20;

Linux Do 客户端 ID

### `OAUTH2_LINUX_DO_CLIENT_SECRET` &#x20;

Linux Do 客户端密钥

### `OAUTH2_FRONTEND_REDIRECT_URI`&#x20;

登陆成功后，重定向到前端的地址

## 插件：Email

### `EMAIL_USERNAME`&#x20;

电子邮箱发件用户

### `EMAIL_PASSWORD`&#x20;

电子邮箱发件用户密码

### `EMAIL_HOST`&#x20;

电子邮箱服务主机地址

### `EMAIL_PORT`&#x20;

电子邮箱服务主机端口号

### `EMAIL_SSL`&#x20;

发送电子邮件时，是否开启 SSL

### `EMAIL_CAPTCHA_REDIS_PREFIX`&#x20;

电子邮件验证码存储到 Redis 时的前缀

### `EMAIL_CAPTCHA_EXPIRE_SECONDS`&#x20;

电子邮件验证码缓存时长

---

---
url: /fastapi_best_architecture_docs/backend/reference/CORS.md
---
当进行前后端项目联调或服务器部署时，你通常会遇到跨域问题，不过没关系，你只需进入 `core/conf.py` 文件，修改
`CORS_ALLOWED_ORIGINS` 配置即可，就可以轻松解决 CORS 相关问题

## 本地

```py
CORS_ALLOWED_ORIGINS: list[str] = [
        'http://localhost:5173',  # 前端访问地址，末尾不带 '/'
    ]
```

## 服务器

::: code-tabs
@tab HTTP

```py
# [!code word:http]
CORS_ALLOWED_ORIGINS: list[str] = [
      'http://服务器ip:端口号',  # 前端访问地址，末尾不带 '/'，当端口号为 80 时，不要添加端口号
  ]
```

@tab  HTTPS

```py
# [!code word:https]
CORS_ALLOWED_ORIGINS: list[str] = [
      'https://域名',  # 前端访问地址，末尾不带 '/'
  ]
```

:::

## 局域网

此方式取决于前端项目是否配置了局域网服务

```py
CORS_ALLOWED_ORIGINS: list[str] = ['*']
```

## 注意事项

::: warning
当将 `CORS_ALLOWED_ORIGINS` 配置为 `['*']` 时，socketio 将无法正常工作，这是由于它们的配置方式不同所导致的

这里有一个相关 PR: [python-engineio/pull/410](https://github.com/miguelgrinberg/python-engineio/pull/410)

虽然它已被合并，但是并没有发布新版本，截至目前，您需要在 `backend/common/socketio/server.py` 文件中修改以下内容：

`cors_allowed_origins=settings.CORS_ALLOWED_ORIGINS` -> `cors_allowed_origins='*'`
:::

---

---
url: /fastapi_best_architecture_docs/backend/reference/CRUD.md
---
# CRUD
我们在 fba 中使用 sqlalchemy-crud-plus 作为数据库操作基类，
它是一款由我们自主构建的基于 SQLAlchemy 2.0 的高级异步 CRUD SDK，它可适用于任何 FastAPI + SQLAlchemy 项目

## 函数命名

fba 遵循以下命名规范：

* 获取/查询详情： `get()`
* 通过 xxx 获取/查询详情：`get_by_xxx()`
* 获取/查询列表表达式：`get_select()`
* 获取/查询列表：`get_list()`
* 获取/查询所有：`get_all()`
* 子查询：`get_children()`
* 关系查询：`get_with_relation()`
* 创建：`create()`
* 更新：`update()`
* 删除：`delete()`

---

---
url: /fastapi_best_architecture_docs/backend/reference/data-permission.md
---
# 数据权限
数据权限是为了给数据添加权限而建立的，我们最常见的实现方式是仅本人数据，本部门数据...
这些就是所谓的数据权限，你可以控制不同的角色拥有不同的数据权限，从而实现用户和数据的隔离

## 弊端

如上所述，我们常见的这种数据权限，在大多数情况下，也能够满足日常场景所需，但是，这种常见的方式存在严重的弊端。由于数据权限的数据过滤是通过
SQL 语句拼接进行实现的，而这些固定权限，直接写死了数据权限的要求，例如：业务表必须包含 dept\_id 和 created\_by 字段，
如果没有这些业务字段，你就无法通过 SQL 来控制数据权限，下面是我对这种常规数据权限的实现，仅供参考：

@[code python](../../code/data_perm.py)

请注意，当前 fba 中已删除此集成方式，你需要自行更新角色 model、schema，添加数据权限控制标识字段 data\_scope 等相关代码

## 想法

有没有一种更加灵活的方案呢，答案是，当然有，目前，我们在 fba
中实现的正式超灵活方案，但是相对于常见方案来讲，可配更加复杂，但我们仍有很大的优化空间

你可以直接查看代码源文件 `backend/common/security/permission.py`，其中，filter\_data\_permission
方法正是我们使用灵活方案，它与常规数据权限使用近乎相同的方式实现数据过滤，但由于其复杂性，下面，我们将通过视频进行讲解： [数据权限管理](https://www.bilibili.com/video/BV13hioY1EQU/?share_source=copy_web\&vd_source=ccb2aae47e179a51460c20d165021cb7)

---

---
url: /fastapi_best_architecture_docs/backend/reference/db.md
---
::: caution
fba 自 v1.10.0 开始，已将默认数据库由 MySQL 替换为 PostgreSQL
:::

fba 支持 PostgreSQL、MySQL 两种数据库，默认配置使用 PostgreSQL

## Docker 镜像

如果你未在本地安装或习惯使用 Docker 镜像，

### PostgreSQL

```shell:no-line-numbers
docker run -d \
  --name fba_postgres \
  --restart always \
  -e POSTGRES_DB='fba' \
  -e POSTGRES_PASSWORD='123456' \
  -e TZ='Asia/Shanghai' \
  -v fba_postgres:/var/lib/postgresql/data \ 
  -p 5432:5432 \
  postgres:16
```

### MySQL

```shell:no-line-numbers
docker run -d \
  --name fba_mysql \
  --restart always \
  -e MYSQL_DATABASE=fba \
  -e MYSQL_ROOT_PASSWORD=123456 \
  -e TZ=Asia/Shanghai \
  -v fba_mysql:/var/lib/mysql \
  -p 3306 \
  mysql:8.0.41 \
  --default-authentication-plugin=mysql_native_password \
  --character-set-server=utf8mb4 \
  --collation-server=utf8mb4_general_ci \
  --lower_case_table_names=1
```

## 环境配置

PostgreSQL 与 MySQL 在用户名、端口号等方面有所不同，如果你使用上面的命令创建了 Docker 镜像，需修改 `.env`
部分配置如下，否则，请根据实际配置进行修改

### PostgreSQL

```dotenv:no-line-numbers
# Database
DATABASE_TYPE='postgresql'
DATABASE_HOST='127.0.0.1'
DATABASE_PORT=5432
DATABASE_USER='postgres'
DATABASE_PASSWORD='123456'
```

### MySQL

```dotenv:no-line-numbers
# Database
DATABASE_TYPE='mysql'
DATABASE_HOST='127.0.0.1'
DATABASE_PORT=3306
DATABASE_USER='root'
DATABASE_PASSWORD='123456'
```

## 解耦

* 删除 `with_variant` 相关代码（如果存在），仅保留数据库对应的类型
* 删除 `backend/core/conf.py` 文件中的 `DATABASE_TYPE` 及其相关的调用代码
* 删除 `.env_example` 和 `.env` 文件中的 `DATABASE_TYPE`
* 更新 `backend/templates/py/model.jinja` 文件中的 `database_type` 相关代码
* 删除 `backend/sql` 目录中的 `postgresql` 或 `mysql` 文件夹
* 删除 `docker-compose.yml` 文件中的 `fba_postgres` 或 `fba_mysql` 容器脚本

---

---
url: /fastapi_best_architecture_docs/backend/reference/i18n.md
---
# 国际化
在现代化 web 开发中，国际化通常是前端需要做的事情，但是，在一些国际场景中，后端国际化也是必不可缺的一部分，它能为特定语言的用户反馈他们的母语提示，极大的方便了全球用户

## 语法

与前端工程常见用法基本一致，只需使用 `t()` 函数 + 链式文本即可，例如：

* `t('response.success')`

获取语言包中的 response 下的 success 字段值

* `t('error.captcha.expired‘)`

获取语言包中的 error 下的 captcha 下的 expired 字段值

## 默认语言

可以在 [配置文件](./config.md) 中设置默认语言

## 动态切换

fba 将自动获取请求头中的 `Accept-Language` 参数，并应用第一个参数值为当前语言，如果此参数不存在，则应用默认语言

```mermaid
---
title: t 函数处理流程
---
flowchart TD
    A[解析链式文本] --> B{获取语言包}
    B -- 存在 --> C[匹配链]
    B -- 不存在 --> D[返回错误提示]
    C -- 成功 --> E[返回语言文本]
    C -- 失败 --> F[返回链式文本]
```

## 语言包

语言包位于 `backend/app/locale` 目录下

### 命名

语言包文件的命名通常遵循国家/地区代码，例如，`en-US` 表示美式英语， `en-GB` 表示英式英语，`zh-CN` 表示简体中文，`zh-TW`
表示繁体中文...

### 格式

语言包目前支持两种格式：

* json
* yaml / yml

---

---
url: /fastapi_best_architecture_docs/backend/reference/jwt.md
---
我们编写了 JWT 授权中间件，使其可以在每次请求发起时，能够实现自动授权，并且还使用 Redis 和 Rust
库对用户信息进行缓存和解析，使其性能影响尽可能降到最低

## 接口鉴权

在文件 `backend/common/security/jwt.py` 中，包含以下代码

```python
# JWT authorizes dependency injection
DependsJwtAuth = Depends(CustomHTTPBearer())
```

我们通过在接口函数中添加此依赖实现 JWT 快速校验，它可以帮助我们检查请求头中是否包含 Bearer Token，使用方式参考如下：

```python{1}
@router.get('/hello', summary='你好', dependencies=[DependsJwtAuth])
async def hello():
    ...
```

## Token

内置 token 授权方式遵循 [rfc6750](https://datatracker.ietf.org/doc/html/rfc6750)

## Swagger 登录

这是一种快捷的授权方式，仅用于调试目的，在服务启动后，进入 Swagger 文档，可通过此调试接口快速获取 token（无需验证码）

## 验证码登录

你可以通过此方式获取 token，在大多数情况下，这更适用于配合前端实现登录授权

我们在 fba 中使用 [fast\_captcha](https://github.com/wu-clan/fast-captcha) 生成 base64 验证码，然后通过接口进行数据返回；您可以通过在线
base64 转图片或配合前端项目将其转为图片进行预览，以下使其工作流程：

```sequence 验证码登录逻辑
actor 客户端
客户端 ->> 路由: GET<br/>/api/v1/auth/captcha
路由 ->> 频率限制器: 校验请求频率
频率限制器 -->> 路由: 允许
路由 ->> fast_captcha: 生成随机验证码
fast_captcha ->> Redis: 缓存验证码
客户端 ->> 路由: POST<br/>/api/v1/auth/login
路由 ->> 频率限制器: 校验请求频率
频率限制器 -->> 路由: 允许
路由 ->> 用户名: 校验用户名是否在系统中存在
用户名 -->> 路由: 通过
路由 ->> 验证码: 校验验证码（缓存和图片内容）
验证码 -->> 路由: 通过
路由 ->> Token: 生成 Token
Token -->> 客户端: 成功
```

---

---
url: /fastapi_best_architecture_docs/backend/reference/limit.md
---
# 节流
我们有一个关于路由器的历史讨论，如果你感兴趣，可以查看：[#70](https://github.com/fastapi-practices/fastapi_best_architecture/discussions/70)

[**fastapi-limiter** GitHub 仓库地址](https://github.com/long2ice/fastapi-limiter){.read-more}

## 使用

更多使用方法请查看官方仓库 [README](https://github.com/long2ice/fastapi-limiter/blob/master/README.md#quick-start)

```python{1,6,11-17,25,29}
@app.get("/", dependencies=[Depends(RateLimiter(times=1, seconds=5))])
async def index_get():
    return {"msg": "Hello World"}


@app.post("/", dependencies=[Depends(RateLimiter(times=1, seconds=5))])
async def index_post():
    return {"msg": "Hello World"}


@app.get(
    "/multiple",
    dependencies=[
        Depends(RateLimiter(times=1, seconds=5)),
        Depends(RateLimiter(times=2, seconds=15)),
    ],
)
async def multiple():
    return {"msg": "Hello World"}


@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    ratelimit = WebSocketRateLimiter(times=1, seconds=5)
    while True:
        try:
            data = await websocket.receive_text()
            await ratelimit(websocket, context_key=data)
            await websocket.send_text("Hello, world")
        except HTTPException:
            await websocket.send_text("Hello again")
```

---

---
url: /fastapi_best_architecture_docs/backend/reference/model.md
---
通用模型位于 `backend/common/model.py` 文件中

## 主键

我们未提供自动主键模式，而是必须通过手动定义的方式进行主键声明

```python
# 通用 Mapped 类型主键, 需手动添加，参考以下使用方式
# MappedBase -> id: Mapped[id_key]
# DataClassBase && Base -> id: Mapped[id_key] = mapped_column(init=False)
id_key = Annotated[
    int,
    mapped_column(
        BigInteger,
        primary_key=True,
        unique=True,
        index=True,
        autoincrement=True,
        sort_order=-999,
        comment='主键 ID',
    ),
]
```

## Mixin 类

[Mixin](https://en.wikipedia.org/wiki/Mixin) 是一种面向对象编程概念, 使结构变得更加清晰

### 操作人

用于集成操作人信息到数据库表

[使用方法请移步至 **操作人**](operator.md){.read-more}

### 日期时间

用于集成日期时间到数据库表，已集成在 [Base](#base-基类) 基类中

```python
class DateTimeMixin(MappedAsDataclass):
    """日期时间 Mixin 数据类"""

    created_time: Mapped[datetime] = mapped_column(
        TimeZone, init=False, default_factory=timezone.now, sort_order=999, comment='创建时间'
    )
    updated_time: Mapped[datetime | None] = mapped_column(
        TimeZone, init=False, onupdate=timezone.now, sort_order=999, comment='更新时间'
    )
```

## 数据类基类

[MappedAsDataclass](https://docs.sqlalchemy.org/en/20/orm/dataclasses.html#orm-declarative-native-dataclasses)

声明性数据类基类，它将带有数据类集成，允许使用更高级配置，==但未集成日期时间=={.note}

```python
class DataClassBase(MappedAsDataclass, MappedBase):

    __abstract__ = True
```

## Base 基类

声明性数据类基类，带有数据类和日期时间集成

```python
class Base(DataClassBase, DateTimeMixin):

    __abstract__ = True
```

---

---
url: /fastapi_best_architecture_docs/backend/reference/oauth2.md
---
# OAuth 2.0
我们在 fba 中使用 [fastapi-oauth20](https://github.com/fastapi-practices/fastapi-oauth20) 集成 OAuth 2.0，您可以在
`backend/app/admin/api/v1/oauth2` 目录中查看我们的官方实现示例

::: note
此授权方式适用于第三方平台认证登录，第三方授权成功后，将依据第三方平台信息自动创建本地用户并自动授权登录，用户只需同意第三方授权即可

但是，想要使用此方式进行授权，你需要先了解 OAuth 2.0 相关知识，并遵循第三方平台认证要求，获取第三方平台授权密钥，最终，手动编码完成集成
:::

---

---
url: /fastapi_best_architecture_docs/backend/reference/operator.md
---
# 操作人
我们常见的后台管理系统中，经常会有一些比如创建人，更新人这类的信息，那这些信息是如何做的呢？下面我们就来讲一讲我们在 fba
中应该如何集成操作人信息

在 fba 中，并没有默认集成操作人员信息到各个数据库表，但是我们提供了非常简易的集成方式：Mixin 类

## 如何集成？

打开 fba 项目 backend 目录，进入 `common/model.py` 文件中，你会看到 `UserMixin` 类就冰冷冷的站在那里，因为 fba
没有使用它，而只是保留它；

```python
class UserMixin(MappedAsDataclass):
    """用户 Mixin 数据类"""

    created_by: Mapped[int] = mapped_column(sort_order=998, comment='创建者')
    updated_by: Mapped[int | None] = mapped_column(init=False, default=None, sort_order=998, comment='修改者')
```

## 如何使用？

首先，`UserMixin` 类所存储的信息只是用户的 id ，这也是一种常见的做法，那么问题来了：我该如何获取用户 id 并存储？
我在后台展示的时候，肯定不能展示 id 吧？容我一一解答

### 如何获取用户 id 并存储

我们 fba 的绝明之处，就是充分利用了请求上下文功能，我们通过 JWT 中间件将用户信息存储到了每个请求的上下文中，后面我们会展开详细讲解
JWT 中间件，然后，我们就可以很轻松的通过 request 对象读取用户信息，在 Django，flask 等 Web 框架中， request 都是常驻嘉宾

首先，在接口函数中，我们要像 Django/flask 一样，第一个参数写为 request，最好，我们加上参数类型：`request: Request`
，然后我们可以在接口函数中通过 `request.user.id` 轻松获取当前操作人员 id ，这样，在存储的时候，此 id 就可以作为存储数据被添加到
schema 或字典中

### 我在后台展示的时候，肯定不能展示 id 吧

当然不能，那该怎么办呢？虽然我们只存储了用户 id 到数据库，但当我们单查询或列表查询的时候，我们需要进行数据拦截，将 id 替换为
username；

这会涉及到另外的问题，username 从哪里来？考虑到性能影响，我们如果每次都遍历这些 id 去查询数据库进行替换，无疑是增加了大量 IO
操作，因此，我们可以埋点（新用户注册后，查询用户列表时...）将所有用户 id 和 username 缓存到 redis，替换的时候就直接读取缓存

## 直接存成 username 不更好么？

当然可以，你可以直接修改 `UserMixin` 存为字符串，然后直接通过 `request.user.username` 存储用户名，这样查询出来就直接是用户名，从而无需再进行替换操作

## 到底存什么？

用 id 还是用 username，取决于业务场景；如果需要总是显示最新用户信息，避免用户更新用户名之后还需要更新所有历史数据，则使用
id，如果 username 是唯一的，并且需要保留历史痕迹，直接用 username 即可

---

---
url: /fastapi_best_architecture_docs/backend/reference/pagination.md
---
# 分页
后期将发生改变，需等待 PR
合并：[Allow to have multiple Query parameter models](https://github.com/fastapi/fastapi/pull/12944#pullrequestreview-2588580175)

---

---
url: /fastapi_best_architecture_docs/backend/reference/pk.md
---
# 主键
我们在 fba 中为数据库主键添加了两种选择，分别为传统模式（自增 ID）和雪花算法（雪花 ID），==我们在全局范围内使用 `自增 ID`
作为主键的默认声明方式=={.note}

在切换主键声明方式之前，让我们先来简单了解一下它们的特性，再决定是否需要切换

## 自增 ID

### 优点

* 简单易用
* 数据库原生支持
* 生成顺序递增
* 查询效率高
* 占用空间小

### 局限性

* 在分布式系统中可能出现 ID 冲突，扩展性较差
* ID 生成依赖数据库，性能瓶颈风险较高
* ID 可预测，可能暴露业务数据量或存在安全隐患

## 雪花 ID

### 优点

* 分布式环境友好
* ID 全局唯一且无需依赖中央数据库
* 包含时间戳，生成 ID 天然有序，便于排序和查询

### 局限性

* 实现复杂，需额外维护生成器
* 可能因时间回拨（如服务器时钟同步问题）导致无法新增数据
* ID 长度较长，存储和传输成本略高

## 适用场景

### 自增 ID

单机或中小规模应用，业务简单且对 ID 可预测性无敏感

### 雪花 ID

分布式系统、微服务架构，或需要高并发、跨地域生成唯一 ID

## 切换选择

### 自增 ID

无需切换，这是 fba 内的全局默认声明方式

### 雪花 ID

1. 更新 fba 内所有 sqlalchemy model 中的 `id: Mapped[id_key]` 为 `id: Mapped[snowflake_id_key]`
2. 更新所有 `id_key` 导入为 `snowflake_id_key`
3. 执行 `backend/sql/init_snowflake_test_data.sql` 脚本初始化测试数据

::: caution Windows 平台警告
如果您正在 Windows 平台中使用 mysql >= 8.0，还需要更新 `backend/database/db.py` 文件内的 `mysql+asyncmy` 为
`mysql+aiomysql`，否则，您将无法在本地正常新增数据。相关
issue：[asyncmy/issues/35](https://github.com/long2ice/asyncmy/issues/35)
:::

## 注意事项

* 使用雪花 ID 时，需确保时钟同步（如通过 NTP）和节点 ID 的唯一性分配
* 传统自增 ID 在数据迁移或合并时需特别注意冲突问题
* \==前端渲染长整数偏移=={.danger}

  当后端 api 返回长整数时，返回结果是没有问题的，但是通过前端渲染数据后，可能导致长整数渲染错误。

  通过浏览器控制台可以发现，前端渲染后的数据 id 与返回数据不一致，最佳解决方法是：后端将长整数序列化为字符串之后再返回

  ::: tabs
  @tab schemaBase

  ```python
  @field_serializer('id', check_fields=False)
  def serialize_id(self, value) -> str:
      return str(value)
  ```

  @tab GetXxxDetail / GetXxxTree

  ```python
  @field_serializer('id')
  def serialize_id(self, value) -> str:
      return str(value)
  ```

---

---
url: /fastapi_best_architecture_docs/backend/reference/RBAC.md
---
# RBAC
我们通过自定义依赖组件，实现了 RBAC 的轻松集成，它可以通过 FastAPI Depends 轻松集成

::: caution
自 fba [v1.2.0](../../changelog.md) 版本起，开始将【角色菜单】作为默认 RBAC 鉴权，Casbin 作为外置插件进行分发
:::

## 角色菜单

要想实现此 RBAC 鉴权，需要进行以下配置

::: steps

1. 添加接口依赖

   只有在接口中添加以下依赖时，才能自动调用此鉴权方式

   ```py{5-6}
   @router.post(
       '',
       summary='xxx',
       dependencies=[
           Depends(RequestPermission('sys:api:add')),  # 通常为 xxx:xxx:xxx
           DependsRBAC,
       ],
   )
   ```

2. 在系统菜单中添加权限标识

   我们在接口依赖中可以看到 `sys:api:add` 之类的值，这些值正是对应着菜单中的权限标识，只有它们完全一致，并且用户拥有对应的菜单时，才可以获得相应的操作权限

:::

## Casbin

此方案是 Go 语言中比较流行的解决方案，它非常灵活，可以通过模型定义多种控制规则

要想实现此 RBAC 鉴权，请先 [获取插件](../../plugin/market.md)，然后执行以下操作

::: steps

1. 安装插件

2. 启用鉴权

   修改 `backend/core/conf.py` 文件中的 `RBAC_ROLE_MENU_MODE` 为 `False`

:::

## 解耦

在实际项目开发中，不可能同时存在多种 RBAC 解决方案，您可以通过以下方式删除【角色菜单】集成

* 删除 `backend/common/security/permission.py` 文件中的 `RequestPermission` 类及所有类调用
* 删除 `backend/core/conf.py` 文件中的 `RBAC_ROLE_MENU_MODE` 和 `RBAC_ROLE_MENU_EXCLUDE`
* 删除 `backend/common/security/rbac.py` 文件中 `rbac_verify` 方法里面的 `if settings.RBAC_ROLE_MENU_MODE:`
  条件及相关代码
* 删除菜单 `perms` 列及其相关的 schema 字段和 SQL 脚本
* 删除菜单 `type` 列中的按钮类型及其按钮类型相关的代码逻辑和 SQL 脚本

---

---
url: /fastapi_best_architecture_docs/backend/reference/response.md
---
# 接口响应
我们为 fba 开发了十分灵活且健全的接口响应系统，它同时适用于任何 FastAPI 应用

## 统一返回模型

在常规 web 应用开发中，通常情况下，响应结构总是统一的，但在 FastAPI 的官方教程中，并没有提示我们该如何这样做，其实，这很简单，
只需我们提供一个统一的 pydantic 模型

```python
class ResponseModel(BaseModel):
    code: int = CustomResponseCode.HTTP_200.code
    msg: str = CustomResponseCode.HTTP_200.msg
    data: Any | None = None
```

以下是使用此模型进行返回的示例（遵循 FastAPI 官方教程），`response_model` 参数和 `->` 类型选择其中一种方式即可，FastAPI
会在内部自动解析并获取最终响应结构

`response_model` 参数：

```python{1,3}
@router.get('/test', response_model=ResponseModel)
def test():
    return ResponseModel(data={'test': 'test'})
```

`->` 类型：

```python{2,3}
@router.get('/test')
def test() -> ResponseModel:
    return ResponseModel(data={'test': 'test'})
```

## Schema 模式

上面我们已经讲解了统一返回模型，但是，FastAPI 中的优势之一还包括完全自动的 OpenAPI 和文档，如果我们全局使用
ResponseModel 做为统一响应模型，你会在 Swagger 文档得到（如图所示）

![response\_model](/images/response_model.png)

显然，我们无法获取响应中的 data 数据结构。此时前端同事找到你，你会告诉他们，你请求一下不就行了？（没毛病，但显然不太友好），下面是我们创建的用于
Schema 模式的统一返回模型

```python
class ResponseSchemaModel(ResponseModel, Generic[SchemaT]):
    data: SchemaT
```

以下是使用此模型进行返回的示例（遵循 FastAPI 官方教程），它的用法与 ResponseModel 基本相似

`response_model` 参数：

```python{1,3}
@router.get('/test', response_model=ResponseSchemaModel[GetApiDetail])
def test():
    return ResponseSchemaModel[GetApiDetail](data=GetApiDetail(...))
```

`->` 类型：

```python{2,3}
@router.get('/test')
def test() -> ResponseSchemaModel[GetApiDetail]:
    return ResponseSchemaModel[GetApiDetail](data=GetApiDetail(...))
```

此时我们再来看一眼 Swagger 文档

![response\_schema\_model](/images/response_schema_model.png)

我们可以看到，响应 Schema 中的 data 已经包含我们的响应体结构了，响应体结构正是解析的 `[]` 中的 Schema 模型，它们是对应的，如果返回的数据结构与
Schema 不一致，将引发解析错误

我们建议将这种方式仅用于查询接口，如果你不需要这种文档，你完全可以不使用它，而是使用更加开放的统一响应模型
ResponseModel

## 统一返回方法

`response_base` 是我们做的全局响应实例，它大大简化了响应返回方式，用法如下：

```python{2-3,7-8}
@router.get('/test')
def test() -> ResponseModel:
    return response_base.success(data={'test': 'test'})


@router.get('/test')
def test() -> ResponseSchemaModel[GetApiDetail]:
    return response_base.success(data=GetApiDetail(...))
```

此实例包含三个返回方法：`success()`、`fail()`、`fast_sucess()`

::: warning
它们都是同步方法，而不是异步。因为这些返回方法并不涉及 io 操作，所以，定义为异步，不但没有性能提升，反而增加了异步协程的开销
:::

::: tabs
@tab `success()`

此方法通常作为默认响应方法使用，默认返回信息如下

```json:no-line-numbers
{
  "code": 200,
  "msg": "请求成功",
  "data": null
}
```

@tab `fail()`

此方法通常在接口响应信息为失败时使用，默认返回信息如下

```json:no-line-numbers
{
  "code": 400,
  "msg": "请求错误",
  "data": null
}
```

@tab `fast_success()`

此方法通常仅用于接口返回大型 json 时，可为 json 解析性能带来质的提升，默认返回信息如下

```json:no-line-numbers
{
  "code": 200,
  "msg": "请求成功",
  "data": null
}
```

:::

## 响应状态码

在文件 `backend/common/response/response_code.py` 中内置了多种定义响应状态码的方式，我们可以根据 `CustomResponseCode` 和
`CustomResponse` 定义自己需要的的响应状态码，因为在实际项目中，响应状态码并没有统一的标准

当我们定义好自定义响应状态码之后，可以像下面这样使用

```python{3-4}
@router.get('/test')
def test() -> ResponseModel:
    res = CustomResponse(code=0, msg='成功')
    return ResponseModel(res=res, data={'test': 'test'})
```

## 驼峰返回

我们默认使用 python 下划线命名法进行数据返回，但是，在实际工作中，前端目前大多使用小驼峰命名法，所以，我们就需要对此进行一些修改来适配前端工程，在文件
`backend/common/schema.py` 中，我们有一个 `SchemaBase` 类，它是我们的全局 Schema 基础类，修改如下：

```python
class SchemaBase(BaseModel):
    model_config = ConfigDict(
        populate_by_name=True,  # [!code ++] 允许通过原始字段名或别名进行赋值
        alias_generator=to_camel,  # [!code ++] 自动将字段名转换为小驼峰
        use_enum_values=True,
        json_encoders={datetime: lambda x: x.strftime(settings.DATETIME_FORMAT)},
    )
```

其中，`to_camel` 方法引入自
pydantic，详情：[pydantic.alias\_generators](https://docs.pydantic.dev/latest/api/config/#pydantic.alias_generators)

完成以上修改后，Schema 模式和返回数据将自动转为小驼峰命名

## 国际化

[请移步至 **国际化**](./i18n.md){.read-more}

---

---
url: /fastapi_best_architecture_docs/backend/reference/router.md
---
# 路由
fba 中的路由遵循 Restful API 规范

## 路由结构

我们有一个关于路由器的历史讨论，如果你感兴趣，可以查看：[#4](https://github.com/fastapi-practices/fastapi_best_architecture/discussions/4)

当前路由结构如下所示：

::: file-tree

* backend 后端
  * app 应用
    * xxx 自定义应用&#x20;
      * api 接口
        * v1
          * xxx 子包
            * **init**.py 在此文件内注册子包内 xxx.py 文件中的路由
            * xxx.py
            * ...
        * **init**.py
        * router.py 在此文件内注册所有子包 **init**.py 文件中的路由
    * xxx 自定义应用&#x20;
      * api 接口
        * v1
          * **init**.py 不做任何操作
          * xxx.py
          * ...
        * **init**.py
        * router.py 在此文件内注册所有 xxx.py 文件中的路由
  * **init**.py
  * router.py 在此文件内注册所有 app 目录下 router.py 文件中的路由

:::

::: warning
我们统一命名了所有接口路由参数为 router，这很有助于我们编写接口，但是，不可忽略的是，在注册路由时，一定要注意我们的导入方式

在 fba 中，我们可以查看所有路由的导入，它们看起来像 `from backend.app.admin.api.v1.sys.api import router as api_router`
，我们这里务必导入文件内的路由参数 `router`，为了避免参数名称冲突，我们可以使用 `as` 为路由参数起一个别名
:::

---

---
url: /fastapi_best_architecture_docs/backend/reference/schema.md
---
# schema
在 fba 中，我们为 Schema 进行了大量量身定制，详情请查看源代码：`backend\common\schema.py`

## 类命名

遵循以下命名规范：

* 基础 schema: `XxxSchemaBase(SchemaBase)`
* 接口入参：`XxxParam()`
* 新增入参：`CreateXxxParam()`
* 更新入参：`UpdateXxxParam()`
* 批量删除入参：`DeleteXxxParam()`
* 查询详情：`GetXxxDetail()`
* 查询详情（包含关系）：`GetXxxWithRelationDetail()`
* 查询树：`GetXxxTree()`

## Field 定义

* 不建议将必填字段默认值设置为 `...`，参考：[必填字段](https://docs.pydantic.dev/latest/concepts/models/#required-fields)
* 建议为所有字段添加 `description` 参数，这对于 API 文档来说非常有用

## 驼峰返回

[请移步至 **接口响应**](response.md#驼峰返回){.read-more}

---

---
url: /fastapi_best_architecture_docs/backend/reference/socketio.md
---
# socketio
## 为什么不用 ws

WebSocket 已被集成到 fastapi 中，并且可以直接使用，为什么还要 socketio？原因有很多，可以简单概括为 socektio 功能性和稳定性更高，如果使用
ws，很多东西可能还要手搓封装，但 socektio 把这些东西基本都写好了，所以，何乐而不为呢

## 什么是 socketio？

socketio 是一种传输协议，可以在客户端和服务器之间实现基于事件的实时双向通信

没有 socketio 时：

你的 leader 在出差，给你任命了一项非常着急的任务，这项任务就等同于事件，但你并不能很快的完成此任务，可是你的 leader
过一会儿就会问你怎么样了（轮询），你很烦，不想理他（延迟反应）

使用 socketio 时：

你的 leader 就坐在你的旁边，你的工作效率飞升，马上就完成了任务，并且直接口头传达了完成，他立马就听见了（实时）

## 集成

在 fba 中，你可以在 `backend/common/socketio/` 目录下查阅本地 socketio 实现，其中包含两个文件

`actions.py`：此文件主要用于定义一些全局事件，方便我们对事件进行统一管理

`server.py`：此文件是在 fba 中的服务端标准实现，其中包含 socketio 授权连接

但这些并不是主要集成代码，我们可以进入 `backend/core/register.py` 文件，找到以下方法

```python
def register_socket_app(app: FastAPI):
    """
    socket 应用

    :param app:
    :return:
    """
    from backend.common.socketio.server import sio

    socket_app = socketio.ASGIApp(
        socketio_server=sio,
        other_asgi_app=app,
        # 切勿删除此配置：https://github.com/pyropy/fastapi-socketio/issues/51
        socketio_path='/ws/socket.io',
    )
    app.mount('/ws', socket_app)
```

我们通过 `python-socketio` ASGI 应用定义方式，分别将 socketio 和 fastapi 应用作为参数填入，此时你已创建了一个 socket
应用，然后我们通过 fastapi 内置的挂载功能，将 socket 应用挂载到 fastapi 应用中，至此，你已完成 fastapi 集成 socketio

---

---
url: /fastapi_best_architecture_docs/backend/reference/sso.md
---
# SSO
SSO（单点登录，Single Sign-On）是一种身份验证机制，允许用户只需登录一次即可访问多个相关系统或应用，无需重复输入凭据

**优点：**

* 提升用户体验，减少登录次数
* 简化企业身份管理，统一权限控制
* 增强安全性，支持多因素认证，降低密码泄露风险

**适用场景**：企业内部系统、云服务、跨平台应用等

## 集成

我们将通过 [casdoor](https://casdoor.org/) 实现 SSO 集成，并将其作为 [SSO 插件](../../market.md) 发布

有关 SSO 的实现细节和更多用法请访问 casdoor 官方文档

---

---
url: /fastapi_best_architecture_docs/backend/reference/timezone.md
---
# 时区
我们为全局精心设计了统一时区，现在，这是一件非常轻松的工作，只需修改 `backend/core/conf.py` 中的时区配置即可改变全局时区

::: caution
时区一旦确定，强烈建议不要后期修改，否则可能造成持久化数据时间信息紊乱！
:::

## 架构应用

无论在架构何处调用时间模块，我们都应使用 `backend/utils/timezone.py` 中提供的现有方法，而不是直接调用 datetime 相关模块

## 数据库

在数据库中处理时区是一件令人头疼的事，常见的方式有以下 3 种：

* 全部存读为 UTC，前端转化（利于国际化管理）
* 全部存读当前时区时间，根据前端传入的时区进行转换（利于本地化管理）
* 全部存储为数值时间戳，前端转化（极其不易管理，但易操作）

让我们来看一个经典案例：

::: chat title="群聊"
{:2025-08-26 12:44:00}

{王}
请教大佬，为啥我查询的时间用的不同的时区和时间戳，返回的数据却是一样的？

![question\_db\_timezone](/images/question_db_timezone.png)

数据库用的是 mysql，原则上这两个 datetime 的时间戳是不一样的，但是查出来的数据是一样的结果；

{王}
我直接写 sql 查询，这个两个是符合预期结果的，第一个有数据，第二个查不到；

![question\_sql\_timezone](/images/question_sql_timezone.png)

这个切换到pg数据库后查询符合预期结果的；

{.}
**timezone**: not used by the MySQL dialect.

sqlalchemy 和所有 python mysql 驱动默认都不处理 mysql 时区信息，通常是直接丢弃，即便使用 TIMESTAMP 类型

{.}
更具体的：[sqlalchemy/1985](https://github.com/sqlalchemy/sqlalchemy/issues/1985)
:::

为此，我们使用了第 2 种解决方案，并创建了自定义 TimeZone 类型，位于 `backend/common/model.py` 文件中，我们可以通过 IDE
点击类名快捷查看使用方式

---

---
url: /fastapi_best_architecture_docs/backend/reference/transaction.md
---
默认情况下，如果将数据库引擎参数 `echo` 设置为 True，你将会看到事务总是被开启，即便那是一个查询语句。但这并不是因为我们错误的使用了
SQLAlchemy，你可以查看 [#6921](https://github.com/sqlalchemy/sqlalchemy/discussions/6921)、[#12782](https://github.com/sqlalchemy/sqlalchemy/discussions/12782)
了解详情

::: details 简要总结
任何遵循 [PEP-429](https://peps.python.org/pep-0249) 进行设计的 Python 数据库连接器或 ORM，都将默认开启事务

在 SQLAlchemy 中，你可以选择不使用它自身的事务模式，但这需要将数据库本身的事务隔离级别设置为 `AUTOCOMMIT`
，详情请查看: [了解 DBAPI 级别的 Autocommit 隔离级别](https://docs.sqlalchemy.org.cn/en/20/core/connections.html#understanding-the-dbapi-level-autocommit-isolation-level)
:::

## Session 生成器

这是一种类似于官方文档的使用方法，但这种方法并没有真正达到事务的目的，因为它不会自动执行提交，所以，你可以将它理解为仅适用于查询，否则，必须手动执行
`commit()` 方法

```python
async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """获取数据库会话"""
    async with async_db_session() as session:
        yield session
        
# Session Annotated
CurrentSession = Annotated[AsyncSession, Depends(get_db)]
```

这种方法通常直接应用于接口函数，在 session 应用方面，它被认为是线程安全的

```python
@router.get('')
async def get_pagination_apis(db: CurrentSession) -> ResponseModel:
    ...
```

## `begin()`

这种方式由 SQLAlchemy 官方实现，在线程安全方面，由于在同一个函数中，可能存在多次调用，所以没有 Session 生成器严谨

```python{2}
async def create(*, obj: CreateIns) -> None:
    async with async_db_session.begin() as db:
        await xxx_dao.create(db, obj)
```

## 如何选择？

以上两种方法，我们更推荐使用 `begin()`，理由如下：

1. 对于 fba 来说，它更加符合架构风格，并且也能减少千篇一律的接口参数（纯作者强迫症）
2. 而对于无需使用自动提交的事务，我们只需将 `begin()` 方法去掉，直接使用 `async_db_session()` 即可

---

---
url: /fastapi_best_architecture_docs/backend/summary/fsm.md
---
# 精简版本
FastAPI 最佳架构精简版的目标是仅保留最最最简单的架构代码，使其更易扩展

## SQLAlchemy

## Tortoise-ORM

::: caution
此版本的更新速度并不同步，我们目前正在积极寻找维护人员
:::

---

---
url: /fastapi_best_architecture_docs/backend/summary/intro.md
---
# 简介
基于 FastAPI 构建的企业级后端架构解决方案

## 伪三层架构

mvc 架构作为常规设计模式，在 python web 中很常见，但是三层架构更令人着迷

在 python web 开发中，三层架构的概念并没有通用标准，所以这里我们称之为伪三层架构

！！！但请注意！！！

我们并没有传统的多 app （微服务）目录结构（django、springBoot...），而是[自以为是的目录结构](#项目结构)

如果您不喜欢这种模式，可以对其进行任意改造！

| 模块   | java           | fastapi\_best\_architecture |
|------|----------------|---------------------------|
| 视图   | controller     | api                       |
| 数据传输 | dto            | schema                    |
| 业务逻辑 | service + impl | service                   |
| 数据访问 | dao / mapper   | crud                      |
| 模型   | entity         | model                     |

## 特性

* \[x] 全局 FastAPI PEP 593 Annotated 参数风格
* \[x] 全面 async/await + asgiref 异步设计
* \[x] 遵循 RESTful API 规范
* \[x] 使用 SQLAlchemy 2.0 全新语法
* \[x] 使用 Pydantic v2 版本
* \[x] 角色菜单 RBAC 访问控制
* \[x] 支持 Celery 异步任务
* \[x] 自研 JWT 认证中间件
* \[x] 支持全局自定义时间时区
* \[x] 支持 Docker / Docker-compose 部署
* \[x] 集成 Pytest 单元测试

## 内置功能

* \[x] 用户管理：分配角色和权限
* \[x] 部门管理：配置组织架构（公司、部门、小组等）
* \[x] 菜单管理：设置菜单及按钮级权限
* \[x] 角色管理：配置角色、分配菜单和权限
* \[x] 字典管理：维护常用参数和配置
* \[x] 参数管理：系统常用参数动态配置
* \[x] 通知公告：发布和维护系统通知公告信息
* \[x] 令牌管理：检测在线状态，支持强制下线
* \[x] 多端登录：支持一键切换多端登录模式
* \[x] OAuth 2.0：内置自研 OAuth 2.0 授权登录
* \[x] 插件系统：热插拔插件设计，降低耦合
* \[x] 定时任务：支持定时，异步任务及函数调用
* \[x] 代码生成：自动生成代码，支持预览、写入和下载
* \[x] 操作日志：记录和查询正常和异常操作
* \[x] 登录日志：记录和查询正常和异常登录
* \[x] 缓存监控：查询系统缓存信息和命令统计
* \[x] 服务监控：查看服务器硬件信息和状态
* \[x] 接口文档：自动生成在线交互式 API 文档

## 项目结构

::: file-tree

* backend 后端
  * alembic/ 数据库迁移
  * app 应用
    * admin/ 系统后台
      * api/ 接口
      * crud/ CRUD
      * model 模型
        * **init**.py 必须在此文件内导入所有模型类
        * …
      * schema/ 数据传输
      * service/ 服务
      * tests/ 单元测试
    * task/ 任务
    * …
  * common/ 公共资源
  * core/ 核心配置
  * database/ 数据库连接
  * log/ 日志
  * middleware/ 中间件
  * plugin 插件
    * code\_generator/ 代码生成
    * …
  * scripts/ 脚本
  * sql/ SQL 文件
  * static/ 静态文件
  * templates/ 模版文件
  * utils/ 工具包
* deploy/ 服务器部署
* …

:::

## 贡献者

## 许可证

本项目由 [MIT](https://github.com/fastapi-practices/fastapi_best_architecture/blob/master/LICENSE) 许可证的条款进行许可

[![Stargazers over time](https://starchart.cc/fastapi-practices/fastapi_best_architecture.svg?variant=adaptive)](https://starchart.cc/fastapi-practices/fastapi_best_architecture)

## 特别鸣谢

* [downdawn](https://github.com/downdawn) 积极推动创建此项目
* [无名](https://github.com/lvright) 精心设计的 LOGO（包含了 fba 三个字母抽象结合，形成了一个类似从地面扩散投影上来的闪电）
* [vuepress-theme-plume](https://github.com/pengzhanbo/vuepress-theme-plume) 为官网文档提供驱动支持
* FastAPI、SQLAlchemy、Pydantic 等开源先行者
* 此项目的所有贡献者、参与者和使用者
* 所有赞助商们（包含所有渠道）的大力支持

---

---
url: /fastapi_best_architecture_docs/backend/summary/quick-start.md
---
# 快速开始
::: caution
fba 仅适用于资深 Python 后端开发人员，如果您是非资深用户，我们建议您从 [精简版](../summary/fsm.md) 开始学习
:::

## 本地开发

:::: steps

1. 准备本地环境

   * Python 3.10+
   * PostgreSQL 16.0 + 或 MySQL 8.0+
     [雪花主键 ID 用户，请先移步到 **切换主键**](../reference/pk.md){.read-more}
     [MySQL 用户，请先移步到 **切换数据库**](../reference/db.md){.read-more}

2. 创建数据库：`fba`

   * PostgreSQL 用户直接创建
   * MySQL 用户创建时需选择 utf8mb4 编码

3. 启动 Redis

4. 准备源码&#x20;

   ::: tabs
   @tab 拉取源代码

   ```shell:no-line-numbers
   git clone https://github.com/fastapi-practices/fastapi_best_architecture.git
   ```

   @tab 创建模板仓库

   此项目支持创建模板仓库，意味着，你可以直接创建一个非 fork 的个人仓库，如图所示，进入此项目
   GitHub 首页，
   使用 `use this template` 按钮创建即可，创建完成之后，使用 `git clone` 命令拉取你自己的仓库即可

   ![use\_this\_template](/images/use_this_template.png)
   :::

5. 安装依赖

   此项目使用 uv 作为项目管理器，建议您 [安装 uv](https://docs.astral.sh/uv/getting-started/installation/)

   如果您本地已经存在 uv，建议通过 `uv self update` 升级至最新版本

   ::: code-tabs
   @tab uv - sync

   ```shell:no-line-numbers
   uv sync
   ```

   @tab uv - pip

   ```shell:no-line-numbers
   uv pip install -r requirements.txt
   ```

   :::

6. env

   在 `backend` 目录打开终端，执行以下命令创建环境变量文件

   ```shell:no-line-numbers
   cp .env.example .env
   ```

7. 按需修改配置文件：`backend/core/conf.py` 和 `.env`

8. 创建数据库表&#x20;

   ::: tabs
   @tab 自动创建
   跳过此步骤，启动 fba 后将自动创建

   @tab Alembic 迁移
   在 `backend` 目录 打开终端

   生成迁移文件

   ```shell:no-line-numbers
   alembic revision --autogenerate
   ```

   执行迁移

   ```shell:no-line-numbers
   alembic upgrade head
   ```

   :::

9. 启动 celery worker, beat 和 flower&#x20;

   在 `根目录` 打开终端，执行以下命令启动 celery 相关服务

   ::: code-tabs
   @tab Worker

   ```shell:no-line-numbers
   fba celery worker
   ```

   @tab Beat

   ```shell:no-line-numbers
   fba celery beat
   ```

   @tab Flower

   ```shell:no-line-numbers
   fba celery flower
   ```

   :::

   ::: warning
   如果从未执行过以上命令，任务结果表将缺失，此时，无论从何处调用任务结果相关接口都会直接报错，直到至少启动一次 worker 和
   beat 服务，相关接口将自动恢复正常
   :::

10. 启动

    在 `根目录` 打开终端，执行以下命令启动 FastAPI 服务

    ```shell:no-line-numbers
    fba run
    ```

11. 初始化测试数据

    架构：执行 `backend/sql/` 目录下对应主键模式的脚本

    插件：执行 `插件/sql/` 目录下对应主键模式的脚本

    ::: info
    你也可以选择通过 [CLI](../reference/cli.md) 快速执行这些脚本
    :::

12. 打开浏览器访问：<http://127.0.0.1:8000/docs>

::::

## 开发流程

::: note
仅供参考，实际以个人开发习惯为准
:::

::: steps

1. 定义数据库模型（[model](../reference/model.md)）

2. 定义数据验证模型（[schema](../reference/schema.md)）

3. 定义路由（[router](../reference/router.md)）

4. 编写业务（service）

5. 编写数据库操作（[crud](../reference/CRUD.md)）

:::

## 单元测试

::: info
通过 `pytest` 运行单元测试，项目内仅提供了非常简易的 demo，并不是完整单元测试，如需要，请自行编写
:::

::: steps

1. 创建测试数据库 `fba_test`，选择 utf8mb4 编码，PostgreSQL 用户可忽略编码
2. 创建数据库表，利用工具创建 `fba` 库所有表的 DDL 脚本，再通过 `fba_test` 库执行
3. 初始化测试数据，通过 `backend/sql/` 目录下对应主键模式的脚本初始化测试数据
4. 在项目根目录打开终端，执行以下单元测试命令

   ```shell:no-line-numbers
   pytest -vs --disable-warnings
   ```

:::

---

---
url: /fastapi_best_architecture_docs/backend/summary/why.md
---
# 为什么选择我们？
> \[!TIP]
> 此仓库作为模板库公开，任何个人或企业均可自由使用！

> \[!IMPORTANT]
> 我们不会去对比任何其他架构，我们认为每个架构都有自己的特点，适用于不同的场景。
>
> 但 fba 绝对是开源架构中，==代码最整洁，最规范且最令人赏心悦目的项目之一=={.important}

## 目标

我们的目标是提供一个最佳架构，让开发者可以快速上手，能够专注于业务逻辑开发，或从此架构中获得灵感，优化本地架构设计，所以我们只会不断完善和优化我们的架构，为开发者带来更好的体验

## 承诺

此仓库作为模板库公开，任何个人或企业均可自由使用！您可以通过 [购买特权](../../price.md) 选择不同版本

## 架构

独一无二，自主研发，自主命名，开发人员可轻松驾驭的独特架构：[伪三层架构](../summary/intro.md#伪三层架构)

## 开放性

* MIT 协议 + 架构源码全量开源
* GitHub 模板仓库，便捷复制和自主命名
* 没有任何以 `fba` 强制命名的内容，也就是说，你可以通过 IDE 统一替换所有 `fba` 关键字为其他

## 灵活性

最具灵活性的代表就是我们的【插件系统】，不仅如此，在接口响应，错误定义，包括架构本身，我们一直在致力于使其既好用又简洁，这些设计对开发者非常友善

## 长期维护

自创建此项目以来，我们已为此项目付出了大量的时间，并且，这仍然在继续！

![Alt](https://repobeats.axiom.co/api/embed/b2174ef1abbebaea309091f1c998fc97d0c1536a.svg "Repo beats analytics image")

## 框架由来

我们有一个完整的关于 fba 由来的 [issues](https://github.com/fastapi-practices/fastapi_sqlalchemy_mysql/issues/5)
，但它被不小心永久删除且无法恢复 😭，我们尝试联系了 GitHub 支持，但不幸的是，我们仍无法获取完整 issues 😭

大致内容为我们的核心团队成员 [downdawn](https://github.com/downdawn) 在 fba 创建之前，找到了 fba
的前身仓库 [fastapi\_sqlalchemy\_mysql](fsm.md#sqlalchemy)，并创建了 issue：【几点讨论与建议】；我们就此 issue
展开了为期数天的讨论，最终决定并创建了
fba

## 套件产物

在创建和迭代 fba 的同时，我们创建了很多与之相关的套件，且他们非常实用，并且我们做到了 0 耦合，您完全可以将它们用到其他与之相关的项目中去

::: center
[more...](https://github.com/orgs/fastapi-practices/repositories?)
:::

## 精简版

尽管我们在 fba
中尽可能地降低了耦合度，但是对于一个简易版本来讲，它需要删除太多东西，因此，我们同时提供了精简版本，详情请查看：[精简版](./fsm.md)

## 质量与规范

* 全局使用 reStructuredText 文档风格

  我们采用了 rest 文档风格，这是一种非常流行的 Python 代码文档，并且，与 IDE 有非常好的集成

* 快速同步框架新特性

  我们追求新事物，拥抱新事物，我们会积极跟进 FastAPI 中的新特性，在不受 Issue 影响的情况下，尽可能地将所有好用的新特性集成进来

* 严格的代码质量

  我们有十分严格的 CI
  代码质量检测和[规则](https://github.com/fastapi-practices/fastapi_best_architecture/blob/master/backend/.ruff.toml)
  ，使用非常流行且强大的 Ruff 作为支撑，为每次 PR 的代码质量做到严格把控

* 持续的认可

  在此我们不做任何宣传引导，您可以在任意社区/交流群发出疑问，我们静待用户真实反馈

---

---
url: /fastapi_best_architecture_docs/blog/contextvar.md
---
在异步编程和并发场景中，如何优雅地管理上下文相关的状态变量？传统的全局变量容易导致状态污染，而线程本地存储（
`threading.local`）又不适合异步任务的嵌套执行

`ContextVar` 正是为此而生，它允许在同一个线程中，根据不同的执行上下文（如协程或任务）持有不同的变量值，而无需显式传递参数

## 什么是 ContextVar？

`ContextVar` 是 `contextvars` 模块的核心类，用于声明和管理上下文变量。它类似于线程本地存储，但专为异步执行环境设计。在
Python 的异步框架如 `asyncio` 中，多个协程可能在同一线程中并发运行，如果使用全局变量，状态很容易在任务间“泄露”。`ContextVar`
通过维护一个每个线程的上下文栈来解决这个问题：每个上下文（`Context` 对象）可以持有变量的快照，进入新上下文时会推入栈顶，退出时自动回滚。

简单来说，`ContextVar` 让你在代码中隐式访问上下文特定的值，比如当前请求的日志追踪 ID，而不用层层传递参数。这在
Web 框架（如 FastAPI 或 Starlette）中特别常见。

## 核心类和方法

`contextvars` 模块主要包含三个类：`ContextVar`、`Token` 和 `Context`。下面是它们的简要说明：

### ContextVar

用于声明上下文变量

* 构造函数：`ContextVar(name, default=None)`，其中 `name` 是字符串用于调试，`default` 是默认值
* 方法：
  * `get(default=None)`：获取当前上下文的值，如果未设置则返回 `default` 或抛出 `LookupError`
  * `set(value)`：设置当前上下文的值，返回一个 `Token` 对象用于回滚
  * `reset(token)`：使用 `Token` 恢复上一个值

### Token

`set()` 返回的对象，用于追踪和恢复变量的旧值

它有属性如 `old_value`（旧值）和 `var`（关联的 `ContextVar`）。从 Python 3.14 开始，`Token` 支持上下文管理器协议，便于使用
`with` 语句

### Context

表示一个上下文映射（类似于字典），管理变量的状态

* `copy_context()`：复制当前上下文（O(1) 复杂度）
* `run(callable, *args, **kwargs)`：在指定上下文中执行可调用对象，执行后自动回滚变化

## 基本使用示例

假设我们有一个名为 `user_id` 的上下文变量，用于追踪当前用户的 ID。

```python
import contextvars

# 声明上下文变量，设置默认值
user_id = contextvars.ContextVar('user_id', default='anonymous')

# 获取当前值
print(user_id.get())  # 输出: anonymous

# 设置新值，返回 Token
token = user_id.set('alice')
print(user_id.get())  # 输出: alice

# 使用 Token 回滚
user_id.reset(token)
print(user_id.get())  # 输出: anonymous
```

再看一个使用 `Token` 作为上下文管理器的例子（Python 3.14+）：

```python
user_id = contextvars.ContextVar('user_id', default='anonymous')

with user_id.set('bob'):
    print(user_id.get())  # 输出: bob
    # 在 with 块内，所有访问都会看到 'bob'

print(user_id.get())  # 输出: anonymous（自动回滚）
```

这比手动 `reset` 更安全，避免了遗忘回滚的风险

## 在异步编程中的应用

`ContextVar` 的真正威力在异步环境中显现。以 `asyncio` 为例，我们可以构建一个简单的回显服务器，其中每个客户端连接的地址存储在上下文中，其他函数无需参数即可访问

```python
import asyncio
import contextvars

# 声明任务 ID 变量
task_id_var = contextvars.ContextVar('task_id', default='none')

async def sub_task():
    # 无需传递参数，直接从上下文中获取
    task_id = task_id_var.get()
    print(f"Sub task running with task_id: {task_id}")
    await asyncio.sleep(0.1)  # 模拟工作

async def main_task(task_id):
    token = task_id_var.set(task_id)
    try:
        await sub_task()
    finally:
        task_id_var.reset(token)

async def main():
    # 并发运行多个任务
    await asyncio.gather(
        main_task('task1'),
        main_task('task2')
    )

# 运行示例
asyncio.run(main())
```

运行这个代码，你会看到输出：

```text
Sub task running with task_id: task1
Sub task running with task_id: task2
```

在这个例子中，sub\_task() 函数无需知道任务 ID，就能从当前上下文中读取它。即使在 asyncio.gather
的并发执行中，每个任务的值也会正确隔离，不会与其他任务混淆。这比显式传递参数更简洁，尤其在深层嵌套的异步调用链中

另一个常见场景是日志追踪：在 ASGI 应用中，将请求 ID 存入 `ContextVar`，然后在任何下游函数中自动注入到日志中

## 与 threading.local 的区别

`threading.local` 提供线程本地存储，每个线程有独立的变量副本，适合多线程程序。但在异步代码中，所有协程共享同一线程，导致
`local` 值在任务间泄露

`ContextVar` 则基于执行上下文栈，支持协程的嵌套和切换：每个任务或生成器有自己的视图，变化在退出时自动回滚

简单比较：

| 特性   | ContextVar             | threading.local |
|------|------------------------|-----------------|
| 适用场景 | 异步/协程（asyncio）         | 多线程             |
| 隔离粒度 | 执行上下文（任务/生成器）          | 线程              |
| 回滚机制 | 自动（通过 Token 或 Context） | 无需回滚，线程隔离       |
| 性能开销 | 低（O(1) 复制）             | 低               |

如果你在用 `asyncio`，优先选择 `ContextVar`

## 注意事项

* **创建位置**：始终在模块顶层创建 `ContextVar`，避免在闭包或函数内创建，否则可能导致内存泄漏（上下文持有强引用）
* **默认值**：使用 `default` 参数避免 `LookupError`，但在异步中要小心默认值的共享
* **兼容性**：Python 3.7+ 支持，原生集成 `asyncio`。在多线程中，每个线程有独立栈
* **调试**：通过 `name` 属性和 `Context.items()` 检查变量状态

---

---
url: /fastapi_best_architecture_docs/blog/custom-exception.md
---
# 如何自定义异常？
我们为 fba 精心设计了全局异常拦截器，它可以自动拦截所有异常信息，并按照标准化的返回信息进行异常信息返回

## 异常拦截器

在异常拦截器中，我们按照标准错误码进行错误处理

在响应中，我们存在两种状态码，分别为返回信息中的状态码和响应状态码；其中，响应状态码默认为编码级，前端完全可以根据此状态码进行异常处理页面跳转，例如，403（无权限操作），404（资源不存在）等等，而返回信息状态码为自定义级，可以在返回时任意自定义

响应状态码遵循 RFC 定义，如果不符合标准，则将状态码处理为 400

```python
def _get_exception_code(status_code: int) -> int:
    """
    获取返回状态码（可用状态码基于 RFC 定义）

    `python 状态码标准支持 <https://github.com/python/cpython/blob/6e3cc72afeaee2532b4327776501eb8234ac787b/Lib/http/__init__.py#L7>`__

    `IANA 状态码注册表 <https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml>`__

    :param status_code: HTTP 状态码
    :return:
    """
    try:
        STATUS_PHRASES[status_code]
        return status_code
    except Exception:
        return StandardResponseCode.HTTP_400
```

异常拦截器还包含：fastapi 数据校验异常，pydantic 数据校验异常，python assert 断言异常，全局未知（未定义）异常，跨域异常，自定义异常，详情请查看源代码：
`backend/common/exception/exception_handler.py`

## 后台任务

了解完异常处理器之后，再来讲讲如何自定义异常，我们先看下面这段代码，这是自定义异常的

```python
class BaseExceptionMixin(Exception):
    code: int

    def __init__(self, *, msg: str = None, data: Any = None, background: BackgroundTask | None = None):
        self.msg = msg
        self.data = data
        # The original background task: https://www.starlette.io/background/
        self.background = background
```

在这段代码中，我们有一个参数为 `background`（由于 fastapi 继承了 starlette，这意味者，fastapi 拥有 starlette
中的所有功能，所以，这里的注释，我们直接导航到了 starlette），它可以让我们添加后台任务，这遵循了 starlette 的后台任务处理，所以，你不仅可以使用
fastapi 中的后台任务定义方式，还完全可以使用 statlette 中的后台任务定义方式

请注意 ==后台任务应附加到响应，并且仅在发送响应后才运行=={.tip}
，这非常重要！并且，任务按顺序执行。如果其中一个任务引发异常，则后面的任务将没有机会执行。所以，我们只推荐为极小的任务使用此方式进行处理！

## 自定义异常

上方我们已经介绍完了自定义异常中包含的其他附加业务，下方我们来讲下如何自定义异常，在文件
`backend/common/exception/errors.py` 中，我们内置了多种自定义异常类，它们结构基本相当，例如：

```python
class NotFoundError(BaseExceptionMixin):
    code = StandardResponseCode.HTTP_404

    def __init__(self, *, msg: str = 'Not Found', data: Any = None, background: BackgroundTask | None = None):
        super().__init__(msg=msg, data=data, background=background)
```

这是我们经常使用的错误类之一，其中，参数 `code` 被定义为编码级响应状态码，参数 `msg`、`data` 对应在返回信息中，fba
会在内部自动处理，参数 `background` 正式我们上方所讲的后台任务

我们来动手试着定义一个：

```python
class 自定义错误类(BaseExceptionMixin):
    code = 遵循 RFC 定义的响应状态码
    
    def __init__(self, *, msg: str = '自定义', data: Any = None, background: BackgroundTask | None = None):
        super().__init__(msg=msg, data=data, background=background)
```

## 如何使用

使用方式非常简单，我们在 fba 代码内任意位置直接使用 `raise errors.xxxError(msg='xxx')` 即可，自定义异常会在异常处理器中自动处理并返回

---

---
url: /fastapi_best_architecture_docs/blog/header-token.md
---
在 FastAPI 官方高级安全教程中，为我们介绍了两种授权方式，分别是 OAuth2 scopes 和 HTTP Basic Auth，两种方式都可以实现
Swagger 文档授权，并且可以在文档界面通过直接登录的方式进行快捷授权

以上两种方式虽然可以实现文档内快捷验证，但是它们都使用了表单登录方式，这对于我们来说，并不是一个理想的方案，所以我们在 fba
中使用了 HTTPBearer，这种方式相对于前两种，不够便捷，但同样可以实现文档内自动授权，需要我们先访问登录接口获取 token，然后填入即可

## 为什么是 Bearer Token?

在实际工作中，诸多情况可能都不会使用 bearer token 这种方式，虽然，很多的系统也在使用 token 进行授权，但往往授权方式五花八门，那为什么是
bearer
token？答案是，没有为什么，这只是一种标准方案，可参考文档：[Authentication Schemas ](https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication#authentication_schemes)

对于我们常规使用的接口工具，例如 Postman、APIfox 等来讲，它们也都实现了 bearer 这种标准授权方式，可以轻松实现自动授权，具体请以官方教程为准

## 自定义 Token 授权方式

好了，上面扯了那么多，回到正题，如何使用非 bearer token 这种方式，而是设置一个自定义请求头实现授权（这里插一句，本身，怎么实现对于后端来说无所谓，如果前端要求
xxx 实现授权才行，那纯属它们懒，如果是技术规格要求，那就再议）

首先，进入 `backend/common/security/jwt.py` 文件中，找到 `DependsJwtAuth = Depends(HTTPBearer())`，将 `HTTPBearer()` 替换为
`APIKeyHeader(name='xxx')`，name 就是我们的自定义请求头 key；由于我们使用的是 bearer 方式，你还需要修改同文件下的
`get_token()` 方法，如下所示：

```python
def get_token(request: Request) -> str:
    authorization = request.headers.get('xxx')  # name
    if not authorization:
        raise TokenError(msg='Token 无效')
    return token
```

修改 JWT 中间件，如下所示：

```python
# 删除以下代码
scheme, token = get_authorization_scheme_param(token)
if scheme.lower() != 'bearer':
    return
```

至此，你已完成自定义 token 授权，在文档中进行授权时，同样需要你需要先登录获取 token，然后填入

但是这种授权方式，对于接口工具来讲，我们则需要手动在请求头中加入 token，而无法实现自动授权，所以，个人还是比较建议使用标准实施

---

---
url: /fastapi_best_architecture_docs/blog/jwt-middleware.md
---
# 为什么要用 JWT 认证中间件？
在构建现代 Web 应用时，安全认证是不可或缺的一环。今天，让我们一起来看看 fba 项目中的 JWT 认证中间件：
`backend/middleware/jwt_auth_middleware.py` 的实现，这将是我们在企业级项目中可应用的最佳实践

## 它解决了什么问题？

如果你正在开发一个需要用户登录的 API 服务，你需要：

* 验证用户身份
* 保护敏感接口
* 在请求间保持用户状态
* 优雅地处理认证失败
* ......

传统方案往往需要你在每个接口中重复编写认证逻辑，或者使用装饰器来包装路由函数，而我们的 JWT 中间件则提供了一种更优雅的集成方式：一次配置，全局生效

## 如何使用它？

例如在 fba 中，我们提供了中间件的统一注册入口：

```python
def register_middleware(app: FastAPI) -> None:
    # ...其他中间件
    app.add_middleware(
        AuthenticationMiddleware,  # 来自 starlette 的认证中间件
        backend=JwtAuthMiddleware(),  # 重写为自定义中间件
        on_error=JwtAuthMiddleware.auth_exception_handler,  # 重写为自定义错误
    )
```

然后在你的路由函数中，就可以直接通过 `request.user` 获取当前登录用户的信息，如下所示：

```python
@router.get("/profile")
async def get_profile(request: Request):
    # 用户信息已经由中间件注入到请求对象中
    current_user = request.user
    return {"user": current_user}
```

我们可以看到，既没有繁琐的依赖注入，也没有重复的认证代码，一切都变得如此简洁

## 与 FastAPI 官方实现的不同之处

FastAPI 官方推荐使用 `OAuth2PasswordBearer` 和依赖注入系统来实现 JWT 认证

```python
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

@router.get("/users/me")
async def get_profile(current_user: User = Depends(get_current_user)):
    return current_user
```

这与我们的 JWT 认证中间件相比吗，看起来只是少了几行代码，但背后的差异却很大：

1. **全局一致性**  ：中间件确保了所有请求都经过相同的认证流程，避免了遗漏
2. **错误处理统一**  ：自定义的错误处理器确保了所有认证失败都返回一致的响应格式
3. **代码简洁**  ：路由函数不再需要显式依赖认证逻辑，关注点更加分离
4. **灵活扩展**  ：中间件架构使得添加新的认证方式或权限检查变得简单

## 为什么推荐 JWT 中间件？

在实际项目中，这种基于中间件的 JWT 认证方案有几个明显优势：

### 对开发者友好

fba 一向注重在这方面考量，而使用此中间件，新加入团队的开发者就不再需要了解复杂的认证机制，只需知道 `request.user`
中包含当前用户信息即可。这大大降低了入门门槛，减少了潜在的安全漏洞

### 统一的错误处理

所有认证相关的错误都通过同一个处理器处理，确保了 API 响应的一致性。无论是 Token 过期还是格式错误，客户端都能收到格式统一的错误信息

### 性能考量

中间件只在必要时执行认证逻辑，对于白名单中的路径（如登录接口、健康检查...）会自动跳过，避免了不必要的性能开销，并且还使用
Redis 和 Rust 库对用户信息进行缓存和解析，使其性能影响尽可能降到最低

## 注意事项

这个中间件设计得足够灵活，可以根据项目需求进行多种扩展，但中间件会应用于每个 API 请求（非认证请求和白名单 API
除外），所以一定要考虑扩展功能的适用性和性能

---

---
url: /fastapi_best_architecture_docs/blog/middleware.md
---
# 如何编写自定义中间件?
在编写中间件之前，我们首先要对中间件有一些了解

## 什么是中间件？

中间件是一种可以自定义处理请求和响应的机制，这种机制可以自动应用于每个请求;

工作机制：当在应用程序中发送一个请求时，会在接口路径（可以理解为接口函数）代码执行前获取它，你可以对此请求进行自定义逻辑处理，然后将处理过的请求再交给接口路径继续执行，在接口响应返回前，你也可以提前获取响应，并对响应进行自定义逻辑处理

在编写自定义中间件时，很多佬可能存在误区，比如：我编写了一个处理请求的普通日志函数，并放到了中间件目录作为中间件；错！这并不是一个中间件，而只是一个工具！它不应该被放到中间件目录，而是应该放到中间件文件中或工具目录中

## 如何编写？

中间件的编写方法有三种

### BaseHTTPMiddleware

这种编写方法相对简单

```python
class AccessMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next: RequestResponseEndpoint) -> Response:
        start_time = timezone.now()
        response = await call_next(request)
        end_time = timezone.now()
        print(f'time: {end_time - start_time}')
        return response
```

编写此类中间件，首先，你要继承 `BaseHTTPMiddleware`，然后重写异步函数：`dispatch()`，在此函数中，`call_next(request)`
之前的代码就是接口路径代码执行前的逻辑处理，之后的代码就是在响应被返回前的逻辑处理，最后，返回响应，至此，你已完成编写自定义中间件

### 纯 ASGI

这种编写方式相对比较复杂

```python
class ASGIMiddleware:
    def __init__(self, app):
        self.app = app

    async def __call__(self, scope, receive, send):
        await self.app(scope, receive, send)
```

这里包含 [ASGI 规范](https://www.starlette.io/middleware/#pure-asgi-middleware)
，除非经过系统性学习，否则，你不能完成编写此类自定义中间件

### 装饰器

这种方式看起来很好，并且是 fastapi 的官方教程，但这不适用于 fba

```python
@app.middleware("http")
async def add_process_time_header(request: Request, call_next):
    start_time = timezone.now()
    response = await call_next(request)
    end_time = timezone.now()
    print(f'time: {end_time - start_time}')
    return response
```

## 如何使用

进入 fba 项目 backend 目录下，找到 `core/registrar.py`，在此文件中找到 `register_middleware()` 函数，这是 fba 的中间件注册函数

在此函数中，==中间件按照从上往下的顺序依次执行==，因此，中间件的顺序非常重要

上面我们提到过使用装饰器编写中间件，但不适用于 fba，经过查看 fastapi 源码，我们发现，此装饰器的本质就是在内部调用了
`add_middleware()` 函数，所以，我们可以直接通过 `app.add_middleware()` 将中间件类添加到应用程序中，这种方式也更符合 fba
当前的编码风格

---

---
url: /fastapi_best_architecture_docs/blog/typing-cast.md
---
在 Python 3.5 引入类型提示以来，渐进式类型系统让我们的代码更易维护、更易协作。但类型检查器有时太“聪明”了，会因为动态数据或第三方库而迷失方向。

`typing.cast` 就像一个“类型声明器”，帮你明确告诉检查器：“嘿，这个值就是这个类型，别多想了！”

## 什么是 typing.cast

`typing.cast` 是 Python 标准库 `typing` 模块中的一个辅助函数。它的核心作用是**在静态类型检查阶段“强制”指定一个值的类型**
，但在运行时，它什么都不做——只是原封不动地返回输入的值。 这设计非常巧妙：它确保了零运行时开销，同时提升了代码的静态安全性

简单来说：

* **静态时**：类型检查器（如 mypy）会认为返回值就是你指定的类型，从而正确推断后续代码
* **运行时**：Python 继续它的鸭子类型哲学，一切照旧

这不同于真正的类型转换（如 `int("123")`），它更像是一个“类型断言”，专为类型提示生态设计

## 如何使用 typing.cast

使用 `typing.cast` 非常简单。它的签名是：

```python
from typing import cast

result = cast(目标类型, 值)
```

* `目标类型`：可以是任何有效的类型提示，如 `int`、`List[str]`、`Optional[Dict[str, int]]` 等
* `值`：你要“转换”的对象，运行时它不会变

让我们通过几个例子来看看它怎么玩转类型提示。

### 示例 1：处理 Any 类型

`Any` 类型是类型提示中的“万金油”，但它会让类型检查器变得宽松。假如你从外部 API 获取数据，知道它其实是 `List[int]`，但检查器只看到
`Any`：

```python
from typing import Any, cast, List

def process_scores(data: Any) -> List[int]:
    # 假设我们已经验证了 data 是整数列表
    scores: List[int] = cast(List[int], data)
    return [score * 2 for score in scores]  # 现在检查器知道 scores 是 List[int]，不会报错

# 使用
raw_data = [1, 2, 3]  # 来自 API 的数据
doubled = process_scores(raw_data)
```

没有 `cast`，mypy 可能会抱怨 `scores` 的类型不明，导致后续列表推导式报错

### 示例 2：从 object 窄化类型

有时函数参数是 `object`（Python 的万能基类），但你知道具体类型：

```python
from typing import cast

def get_length(item: object) -> int:
    # 假设 item 已被检查为 str
    length: int = len(cast(str, item))  # 告诉检查器：item 是 str
    return length

# 使用
result = get_length("hello")  # 运行正常，检查器也满意
```

### 示例 3：第三方库集成

集成像 `requests` 这样的库时，返回值往往是 `Any`。用 `cast` 可以快速窄化：

```python
import requests
from typing import cast, Dict, Any

response = requests.get("https://api.example.com/data")
data: Dict[str, int] = cast(Dict[str, int], response.json())  # 假设我们知道 JSON 是这个结构
total = sum(data.values())  # 检查器现在知道 data 是 Dict[str, int]
```

这些例子展示了 `cast` 如何在不改动运行逻辑的情况下，提升代码的可读性和工具支持

## 实际应用场景

`typing.cast` 最常出现在这些地方：

* **动态数据处理**：如 JSON 解析、配置文件读取
* **遗留代码迁移**：逐步添加类型提示时，桥接动态和静态部分
* **低级 API**：如 C 扩展或网络协议解析，类型不明显
* **测试与模拟**：mock 对象需要精确类型

在大型项目中，它能减少类型检查器的噪音，让开发者专注于真正的问题

## 注意事项

`cast` 虽然强大，但也有风险：

* **无运行时保护**：它不会验证类型，如果你的假设是错误的（如 `cast(int, "abc")`），运行时会炸锅
* **滥用风险**：过度使用会隐藏真实类型错误，降低代码质量。记住，它是“逃生舱”，不是日常工具
* **最佳实践**：优先用条件检查（如 `isinstance`）或更精确的类型提示。只有当检查器“顽固”时，才祭出 `cast`。另外，从 Python 3.11
  开始，还有 `typing.assert_type` 可以辅助验证，但它也只在静态阶段生效

---

---
url: /fastapi_best_architecture_docs/frontend/deploy/docker.md
---
# Docker 部署
::: warning
此教程以 https 为例
:::

:::: steps

1. 拉取代码到服务器

   将代码拉取到服务器通常采用 ssh 方式（更安全），当然你也可以选择使用 https 方式，具体方式请根据个人自行决定

2. env

   修改 `/apps/web-antd/.env.production` 中的 `VITE_GLOB_API_URL` 为域名地址（末尾不带斜杠）

3. 更新 nginx 配置

   文件 `/scripts/deploy/nginx.conf` 中有相关注释说明，根据需要进行修改即可

4. 更新 `docker-compose` 脚本

   ::: caution 构建条件（不满足不要继续）

   * 注释了 fba 后端 docker-compose 脚本中的 fba\_ui 容器
   * 已经通过 docker-compose 构建 fba 后端

   :::

   脚本 `docker-compose.yml` 中有相关注释说明，根据需要进行修改即可

5. 执行一键启动命令

   在项目根目录中打开终端，执行以下命令

   ```shell:no-line-numbers
   docker-compose up -d --build
   ```

::::

---

---
url: /fastapi_best_architecture_docs/frontend/deploy/legacy.md
---
# 传统部署
::: steps

## 服务器

1. 准备 Nginx

   以 Ubuntu 为例：

   ```shell
   sudo apt update
   sudo apt install nginx -y
   ```

2. 更新配置

   将 [nginx.conf](https://github.com/fastapi-practices/fastapi_best_architecture_ui/blob/master/scripts/deploy/nginx.conf)
   替换到 `/etc/nginx/nginx.conf`

## 本地

1. env

   更新 `.env.production` 配置文件

2. 打包

   ```shell
   pnpm build
   ```

3. 上传

   将 `/apps/web-antd/dist` 目录下的所有文件上传到服务器的 `/var/www/fba_ui/` 目录下

---

---
url: /fastapi_best_architecture_docs/frontend/summary/arco.md
---
# Arco Design Pro 实验性实施
\==此版本已停止更新维护！=={.danger}

我们已于 2025 年 3 月 29 日对 Arco 仓库进行封存，此后它将不再接收任何更新。尽管做出这一决定让我们心生不舍，毕竟 Arco
曾承载了我们无数的探索与期待，但技术的脚步永不停歇，为了顺应更高效、更前沿的发展需求，我们不得不迈向新的篇章。

至此，承蒙每一位大佬的厚爱，请与我们携手共进，打开 [Vben Admin Antd](intro.md) 新篇章

::: note
此实施内部通过硬编码实现了 Casbin RBAC 鉴权，如需解耦，需手动删除 casbin、API 管理及其所有调用
:::

::: caution
此实施自 fba [v1.0.4](../changelog.md) 版本起，正式宣告其使命完结，fba 后续版本将不再对此进行适配，请不要将其用于生产！
:::

---

---
url: /fastapi_best_architecture_docs/frontend/summary/intro.md
---
# 介绍
基于 Vben Admin Antd 构建的 fastapi\_best\_architecture 前端完整版实施

::: warning
fba 从始至终一直是企业级后端架构解决方案，并没有针对前端的专项计划，前端项目只是一项附加产物

我们的团队中没有专业的前端工程师，如果您都此项目的发展和实施有更好的见解，请直接创建 Issues 或 PR
:::

---

---
url: /fastapi_best_architecture_docs/frontend/summary/quick-start.md
---
# 快速开始
::: warning
前端已默认集成<字典>功能，所以后端必须配置<字典插件>，并执行字典插件中的 SQL 脚本
:::

::: steps

1. 准备本地环境

   * Node.js（20.15.0 及以上版本）

2. 拉取 Git 仓库

   ```shell
   git clone https://github.com/fastapi-practices/fastapi_best_architecture_ui.git
   ```

3. 安装依赖

   ```shell
   pnpm install
   ```

4. 启动

   ```shell
   pnpm dev
   ```

:::

---

---
url: /fastapi_best_architecture_docs/group.md
---
# 交流群
[通过 fba 作者主页与他互动](https://wu-clan.github.io/homepage/){.read-more}

## Discord

Discord 社区是我们的开发技术交流平台，这是一个充满活力的开源社区群组，欢迎来自全球的开发者、爱好者和用户。在这里，
大家可以自由分享想法、讨论技术、协作项目，或是获取最新的更新与支持。加入我们，一起参与这场开源之旅吧！

:::center
[点击加入](https://discord.com/invite/yNN3wTbVAC)
:::

## 微信群

如果您的网络环境受限，可选择此群组 （二维码过期请通过 Discord 与我们联系）

此群组由于功能和管理受限，不会发布公告，动态等相关信息

::: caution
对于需要提供大量源码或截图的问题，请通过 Discord 进行提问，因为 Discord 对代码输入格式化更加友好
:::

---

---
url: /fastapi_best_architecture_docs/join.md
---
# 加入团队
[FastAPI Practices](https://github.com/fastapi-practices) 及其生态系统的成长离不开开源社区的支持，如果您喜欢我们的产品并愿意参与其中，我们将不胜荣幸。

我们会根据您的 PR 和参与度作为评估标准，诚邀您加入我们的 [团队](https://github.com/orgs/fastapi-practices/people)
，或将您的信息添加到我们的 [官网](./team.md)。如果您对此有意向，请通过 Discord 与我们联系，并提供以下信息（可直接复制并填写）

```
**昵称：** xxx
**个人描述：** xxx
**GitHub 链接：** xxx
**城市坐标：** 城市+省/直辖市
**个人主页：** xxx（默认为 GitHub 链接）
**PR 链接：** xxx（如果有）
```

---

---
url: /fastapi_best_architecture_docs/market.md
---
# 插件市场

---

---
url: /fastapi_best_architecture_docs/opensource.md
---
# 开源项目
在此之前，让我们通过维基百科简单了解下 [开源](https://zh.wikipedia.org/wiki/%E5%BC%80%E6%BA%90%E8%BD%AF%E4%BB%B6) 这个词

## 官方

## 第三方

请移步至 [用户登记](./users.md#开源项目)

---

---
url: /fastapi_best_architecture_docs/plugin/before.md
---
# 前言
::: warning
为了维护您的个人权益，在开始使用插件之前，请务必仔细阅读完此文档
:::

## 愿景

提供一个共创平台，告别高耦合集成，让功能变得可轻松 Hot Swap（热插拔）

遗憾的是，我们并不会提供插件管理平台对插件进行统一管理，我们计划将所有插件在 [插件市场](../market.md) 进行展示和导航

## 开发

请移步至 [插件开发](dev.md)

## 收费吗

取决于插件开发者

## 是否提供源码

取决于插件开发者

## 可商用吗

取决于插件开发者

## 技术支持

需自行联系插件开发者

## 免责声明

* 对于使用恶意插件程序造成的损失，我们无需承担任何责任
* 对于付费插件作者跑路行为，我们无需承担任何责任

---

---
url: /fastapi_best_architecture_docs/plugin/dev.md
---
::: info
在官方仓库中，包含多个内置插件，位于 `backend/plugin` 目录下，结合官方仓库阅读此文档，效果更佳
:::

## 后端

::: steps

1. 拉取最新的 fba 项目到本地并配置好开发环境

2. 通过 [插件类型](#插件类型)、[插件路由](#插件路由)、[插件配置](#插件配置)、[数据库兼容性](#数据库兼容性)
   了解插件系统的运作机制

3. 根据 [插件目录结构](#插件目录结构) 进行插件开发

4. 完成插件开发

5. [插件分享](./share.md)&#x20;

:::

### 插件类型

::: tabs#plugin
@tab 应用级插件
在 [项目结构](../backend/summary/intro.md#项目结构) 中，app
目录下的一级文件夹被视为应用，此原理同样应用于插件系统。

此类插件会像应用一样被注入到系统中，我们称这类插件为【应用级插件】

@tab 扩展级插件
此类插件会被注入到 app 目录下已存在的应用中，我们称这类插件为【扩展级插件】
:::

### 插件路由

如果插件符合插件开发的要求，则插件中的所有路由都将自动注入到 FastAPI 应用中。但值得注意的是，启动时间可能会随着插件数量的递增而增加，因为
fba 会在每次启动前对所有插件进行实时解析

::: tabs#plugin
@tab 应用级插件
应完全遵循 [路由结构](../backend/reference/router.md#路由结构) 进行开发

@tab 扩展级插件
必须将应用中的 api 目录结构进行 1:1 复制，可参考 fba
中的内置插件 [notice](https://github.com/fastapi-practices/fastapi_best_architecture/tree/master/backend/plugin/notice/api)
:::

### 插件配置

`plugin.toml` 是插件的配置文件，每个插件都必须包含此文件

::: tabs#plugin
@tab 应用级插件

```toml
# 插件信息
[plugin]
# 摘要（简短描述）
summary = ''
# 版本号
version = ''
# 描述
description = ''
# 作者
author = ''

# 应用配置
[app]
# 路由器最终实例
# 可参考源码：backend/app/admin/api/router.py，通常默认命名为 v1
router = ['v1']
```

@tab 扩展级插件

```toml
# 插件信息
[plugin]
# 摘要（简短描述）
summary = ''
# 版本号
version = ''
# 描述
description = ''
# 作者
author = ''

# 应用配置
[app]
# 扩展的哪个应用
extend = '应用文件夹名称'

# 接口配置
[api.xxx]
# xxx 对应的是插件 api 目录下接口文件的文件名（不包含后缀）
# 例如接口文件名为 notice.py，则 xxx 应该为 notice
# 如果包含多个接口文件，则应存在多个接口配置
# 路由前缀，必须以 '/' 开头
prefix = ''
# 标签，用于 Swagger 文档
tags = ''
```

:::

### 数据库兼容性

fba 内所有官方实现都同时兼容 mysql 和 postgresql，但我们不对第三方插件进行强制要求，如果您对此感兴趣，请查看 SQLAlchemy 2.0
官方文档：[TypeDecorator](https://docs.sqlalchemy.org/en/20/core/custom_types.html#typedecorator-recipes)、
[with\_variant](https://docs.sqlalchemy.org/en/20/core/type_api.html#sqlalchemy.types.TypeEngine.with_variant)

### 插件目录结构

插件统一放置在 `backend/plugin` 目录下，以下是插件的目录结构

::: file-tree

* xxx 插件名&#x20;
  * api/ 接口&#x20;
  * crud/ CRUD
  * model 模型
    * **init**.py 在此文件内导入所有模型类&#x20;
    * …
  * schema/ 数据传输
  * service/ 服务
  * sql 如果插件需要执行 SQL 则建议
    * mysql
      * init.sql 自增 id 模式
      * init\_snowflake.sql 雪花 id 模式
    * postgresql
      * init.sql 自增 id 模式
      * init\_snowflake.sql 雪花 id 模式
  * utils/ 工具包
  * **init**.py 作为 python 包保留&#x20;
  * … 更多内容，例如 enums.py...
  * plugin.toml 插件配置文件&#x20;
  * README.md 插件使用说明和您的联系方式&#x20;
  * requirements.txt 依赖包文件

:::

## 前端

::: steps

1. 拉取最新的 fba\_ui 项目到本地并配置好开发环境

2. 根据 [插件目录结构](#插件目录结构-1) 进行插件开发

3. 完成插件开发

4. [插件分享](./share.md)&#x20;

:::

### 插件目录结构

插件统一放置在 `apps/web-antd/src/plugins` 目录下，以下是插件的目录结构

::: file-tree

* xxx 插件名
  * api 接口
    * index.ts
  * langs 多语言
    * en-US
      * 插件名.json
    * zh-CN
      * 插件名.json
  * routes 路由
    * index.ts
  * views 视图
    * index.vue
    * …
  * … 更多内容

:::

## 注意事项

非必要情况下，插件代码中尽量不要引用架构中的现有方法，如果架构中的现有方法发生变更，则插件也必须同步变更，否则插件将被损坏

---

---
url: /fastapi_best_architecture_docs/plugin/install.md
---
# 插件安装
::: caution
切勿在线上环境直接安装插件，以免带来不必要的损失
:::

## 后端

:::: tabs
@tab 手动

1. 获取插件仓库源码并下载
2. 将下载的源码文件夹直接拷贝到 `backend/plugin` 目录下
3. 根据插件说明（README.md）进行相关配置
4. 重启服务

@tab ZIP

1. 获取打包好的插件 zip 压缩包&#x20;

   * 下载插件仓库为 zip 压缩包

     ::: details GitHub 示例
     ![zip](/images/plugin_zip.png)
     :::

   * 通过 fba 插件下载接口下载的 zip 压缩包

2. 将 zip 压缩包通过 fba zip 插件安装接口进行安装

3. 根据插件说明（README.md）进行相关配置

4. 重启服务

@tab GIT

1. 获取插件 git 仓库地址，理论上支持任何平台（GitHub、Gitlab、Gitee、Gitea...）
2. 通过 fba git 插件安装接口进行安装
3. 根据插件说明（README.md）进行相关配置
4. 重启服务

@tab CLI

1. 通过在命令行输入 `fba add -h` 获取相关信息
2. 通过 `fba add` 命令进行安装
3. 根据插件说明（README.md）进行相关配置
4. 重启服务

::::

::: warning
任意方式安装插件后，在重启 fba 服务前，务必检查插件内的 sqlalchemy model
文件（如果存在）中的主键模式是否与你当前正在使用的主键模式相匹配，参考：[切换主键](../backend/reference/pk.md)
:::

## 前端

1. 获取插件仓库源码并下载
2. 将下载的源码文件夹直接拷贝到 `apps/web-antd/src/plugins` 目录下
3. 重启服务

---

---
url: /fastapi_best_architecture_docs/plugin/share.md
---
# 插件分享
## 后端

:::: steps

1. 创建个人插件仓库

   推荐使用插件模板仓库 [fba\_plugin\_template](https://github.com/fastapi-practices/fba_plugin_template) 创建个人插件仓库

   ::: warning 插件仓库命名规则
   `个人插件仓库名 == 插件名`

   假如你的个人插件仓库命名为 `sms`，安装此插件后，`backend/plugin` 目录下就会新增一个 `sms` 文件夹

   插件总是独一无二的，不允许安装同名插件，所以我们在对插件进行命名时，应尽量保持其独特性
   :::

   ![repo](/images/plugin_template.png)

2. 上传代码

   将在 fba 中开发好的所有插件代码拷贝到个人插件仓库中

   ::: caution
   应拷贝插件目录中的所有文件，而不是直接拷贝插件目录
   :::

::::

## 前端

:::: steps

1. 创建个人插件仓库

   使用插件模板仓库 [fba\_ui\_plugin\_template](https://github.com/fastapi-practices/fba_ui_plugin_template) 创建个人插件仓库

   ::: warning 插件仓库命名规则
   `个人插件仓库名 == 插件名_ui`

   假如你的个人插件仓库命名为 `sms_ui`，安装此插件后，`apps/web-antd/src/plugins` 目录下就会新增一个 `sms` 文件夹

   插件总是独一无二的，不允许安装同名插件，所以我们在对插件进行命名时，应尽量保持其独特性
   :::

2. 上传代码

   将在 fba\_ui 中开发好的所有插件代码拷贝到个人插件仓库中，==仅限 Vben Admin Antd 工程=={.warning}

   ::: caution
   应拷贝插件目录中的所有文件，而不是直接拷贝插件目录
   :::

::::

## 发布

我们创建了一个简易的 [插件市场](../market.md)，用于插件展示和导航

如果您开发的插件与 fba 兼容，欢迎在 Discord
社区的 [插件系统](https://discord.com/channels/1185035164577972344/1349951379560599572) 频道与我们分享

---

---
url: /fastapi_best_architecture_docs/pricing.md
---
# pricing

---

---
url: /fastapi_best_architecture_docs/privacy-policy.md
---
# 隐私政策
2.2 信息存储的地域

2.3 产品或服务停止运营时的通知

---

---
url: /fastapi_best_architecture_docs/questions.md
---
# 常见问题
::: tip
如果以下解决方案未能帮助到您，请通过 [交流群](./group.md) 与我们联系
:::

## 返回数据跟数据库对不上

### 非首次部署或反复部署

若此前已调用过 fba 接口，相关数据可能已悄无声息地写入 Redis 缓存。随后，即便重新部署了 fba，整个部署过程并不会自动清除
Redis 中的缓存数据。

因此，调用重新部署后的 fba 接口时，若发现返回数据异常，而数据库检查又未发现问题，很可能是缓存未更新导致。此时，手动清理
Redis 中的 fba 缓存即可解决问题，系统将自动恢复正常

### 手动修改数据库数据

假设我们直接在数据库中修改了某些数据，但调用接口后发现返回结果未发生变化。返回数据可能来源于 Redis
缓存，而通过数据库直接修改的操作不会触发缓存的自动更新。

因此，返回数据看似未受影响。解决方法是手动清理 Redis 中的相关缓存，之后数据将正确反映修改结果

## Can't call await\_only() here

```json
{
  "code": 500,
  "msg": "(sqlalchemy.exc.MissingGreenlet) greenlet_spawn has not been called; can't call await_only() here. Was IO attempted in an unexpected place?\n[SQL: SELECT sys_dict_data.id AS sys_dict_data_id, sys_dict_data.label AS sys_dict_data_label, sys_dict_data.value AS sys_dict_data_value, sys_dict_data.sort AS sys_dict_data_sort, sys_dict_data.status AS sys_dict_data_status, sys_dict_data.remark AS sys_dict_data_remark, sys_dict_data.type_id AS sys_dict_data_type_id, sys_dict_data.created_time AS sys_dict_data_created_time, sys_dict_data.updated_time AS sys_dict_data_updated_time \nFROM sys_dict_data \nWHERE %s = sys_dict_data.type_id]\n[parameters: [{'%(2071788311008 param)s': 1}]]\n(Background on this error at: https://sqlalche.me/e/20/xd2s)",
  "data": null,
  "trace_id": "89afd9b0f2b8442590661701e2b6b495"
}
```

![await\_only](/images/sqlalchemy_await_only.png)

在 SQLAlchemy 2.0 中异步中，关系（relationship）表默认使用
[懒加载](https://docs.sqlalchemy.org/en/20/glossary.html#term-lazy-loading)，所以，如果你未在 ORM 语句中添加关联字段的
加载策略，那么关联字段可能被定义为错误（如上图所示），此时如果调用 pydantic / fastapi 序列化，那么将触发字段错误，因为字段本身就是个错误

可用的解决方案有多种，请阅读 SQLA 官方文档，fba 默认使用 `noload()` 对此进行处理，例如：

```python
return await self.select_order(  # [!code word:noload]
   'id',
   'desc',
   load_options=[
       selectinload(self.model.dept).options(noload(Dept.parent), noload(Dept.children), noload(Dept.users)),
       selectinload(self.model.roles).options(noload(Role.users), noload(Role.menus), noload(Role.scopes)),
   ],
   **filters,
)
```

## PostgreSQL 主键自增失败

当通过 sql 脚本执行插入数据后，由于 pg 特性，序列值不会与表中最大值同步，此时如果通过代码执行写入操作，可能触发
`DETAIL: Key (id)=(x) already exists` 的错误

解决方案请自行浏览器搜索：如何重置 pg 主键序列？

## 数据库时区陷阱

MySQL 不支持时区存储类型，而 PostgreSQL 拥有完美的时区类型，所以在数据库中存储时间列确实是一件令人头疼的事情，不过我们已经实现完美方案，兼容
pgsql 和 mysql，[查看详情](./backend/reference/timezone.md)

---

---
url: /fastapi_best_architecture_docs/sponsors.md
---
# 成为 fba 的赞助者
::: note 用爱发电，回馈开源
fba 是一款基于 FastAPI 框架的后端架构解决方案，遵循伪三层架构设计，支持 Python 3.10 及以上版本。

自 2023/04/07 启，我们一直致力于[持续更新和维护](./backend/summary/why.md#长期维护)，为此，我们投入了大量的时间和无限的热爱
:::

## 荣誉赞助

::: tip
请通过 [Discord](./group.md) 与我联系并发送赞助截图，以获取专属身份标签
:::

## 展位赞助商

您可以通过 [fba 作者主页](https://wu-clan.github.io/homepage/) 内任意联系方式就展位的详细事宜与他进行沟通

::: caution
展位转化效果可能因市场环境、受众行为等多种因素影响，我们无法保证确切的转化结果
:::

::: warning 展位赞助说明
选择【独家展位、特别展位】赞助，可帮助您的产品在 Discord 社区以公告的形式进行推广一次

* 优先推广和程序员相关的互联网产品，比如：低代码开发平台、网课、开发软件、云服务器、个人博客等等，实体产品如键盘、显示器、耳机等等，如果是和程序员无关的产品，可酌情考虑是否推广
* 拒绝接受违反法律法规、灰色相关的产品推广（GPT 相关不包含在内）

公告消息如下：

```
感谢 xxx 老板对 fba 项目的慷慨赞助，以下是老板的产品，大家感兴趣的可以关注一下：
xxx 商品名称
链接：https://xxx.xx
```

您也可以提供自定义非政治、法律法规敏感推广词/图片

:::

## 注意事项

> \[!CAUTION]
> 由于当前所有赞助均为自愿支持性质，我们暂时无法为您提供发票开具服务，对此带来的不便深表歉意。
>
> 您的每一份支持都是我们持续前进的动力，期待未来能以更完善的方式回馈您的信任。若需进一步沟通，欢迎随时联系

---

---
url: /fastapi_best_architecture_docs/stack.md
---
# 技术栈
采用当前主流技术框架，我们追求新事物，拥抱新事物，并且积极更新与跟进

\==技术框架采用基准取决于项目的流行度、活跃度、答复效率以及维护周期等==

## 后端

## 前端

---

---
url: /fastapi_best_architecture_docs/users.md
---
# 用户登记
在进行用户调研时，一个常见且关键的问题是：==这个项目有人在生产环境中使用吗？=={.important}

面对这样的询问，仅仅依赖口头回答往往显得苍白无力，而使用登记数据则更为直观且有力

> \[!IMPORTANT]
> 如果您/您所在的企业/组织使用了 fba 进行项目开发，我们诚挚的邀请您参与：
> [用户登记](https://github.com/fastapi-practices/fastapi_best_architecture/issues/477)

## 公司 / 组织

## 开源项目
